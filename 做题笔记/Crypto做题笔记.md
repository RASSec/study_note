# Crypto做题笔记

## 攻防世界

### 你猜猜

##### 解题思路



题目提供文件

haha.txt

```
504B03040A0001080000626D0A49F4B5091F1E0000001200000008000000666C61672E7478746C9F170D35D0A45826A03E161FB96870EDDFC7C89A11862F9199B4CD78E7504B01023F000A0001080000626D0A49F4B5091F1E00000012000000080024000000000000002000000000000000666C61672E7478740A0020000000000001001800AF150210CAF2D1015CAEAA05CAF2D1015CAEAA05CAF2D101504B050600000000010001005A000000440000000000
```

看别人的wp知道了504B0304是Zip的文件头

HxD新建文件，将`haha.txt`中的数据copy进去，命名为`1.zip`

压缩文件需要密码直接爆破(工具:ziperello)

##### 收获

zip的文件头:504B0304

工具:HxD,ziperello(破解压缩文件密码)

### 告诉你个秘密

### 思路

题目给你两个字符串

>636A56355279427363446C4A49454A7154534230526D6843
>56445A31614342354E326C4B4946467A5769426961453067

尝试看成hex编码,试一下

得到

>cjV5RyBscDlJIEJqTSB0RmhC
>
>VDZ1aCB5N2lKIFFzWiBiaE0g

尝试base64decode

>r5yG lp9I BjM tFhB
>T6uh y7iJ QsZ bhM 

到这边就是我会做的全部了

试了一堆最后百度发现

你妈是看键盘

> 在键盘上`r5yg`中间的字母是`t`,同理，将其他的也找出来，得到
>
> TONGYUAN



### **Easy-one**


  做这题的时候我没有事先进行分析，一直以为密钥是CENSORED

看了别人的wp才发现这题的密钥不是CENSORED。





msg001.enc是msg001的加密文件,已知过程直接逆向出密钥。

贴上代码

```c
//获取密钥
#define false 0
#define true 1
int main() {
	FILE* input  = fopen("msg001", "rb");
	FILE* output = fopen("msg001.enc", "rb");
	if (!input || !output) {
		printf("Error\n");
		return 0;
	}
	int c, p, t = 0;
	char k[30]="";
	int i = 0;
	while ((p = fgetc(input)) != EOF &&(c= fgetc(output))!=EOF  ) {
		char ch;
		//(p + (k[i % strlen(k)] ^ t) + i*i) & 0xff;
		int ok=false;
		while(1)
		{
			for(ch=32;ch<127;ch++)
			{
				printf("未加密:%d,测试加密:%d,正确加密:%d,猜测k:%d\n",p,(p + (ch ^ t) + i*i) & 0xff,c,ch);
				if((p + (ch ^ t) + i*i) == c)
				{
					ok=true;
					break;
				}
			}
			if(ok)
				break;
			else c+=256;
		
		}
		
			
		k[i]=ch;
		t = p;
		i++;
	}
	k[i+1]=0;
	printf("%s",k);
	return 0;
}


//解密
int main() {

	FILE* input  = fopen("msg002.enc", "rb");
	char k[] = "VeryLongKeyYouWillNeverGuess";
	char c, p, t = 0;
	int i = 0;
	while ((p = fgetc(input)) != EOF) {
		 
		//(p + (k[i % strlen(k)] ^ t) + i*i) & 0xff;
		c = (p-i*i-(k[i % strlen(k)] ^ t));
		t = c;
		i++;
		printf("%c",c);
	}
	return 0;
}
```



### 幂数加密(云影密码)

• 云影密码仅包含01248五个数字，其中0用于分割，其余数字用于
做和之后转换为明文

```python

s="8842101220480224404014224202480122"
s=s.split("0")
print(s)
for i in s:
	res=0
	for j in i:
		res+=int(j)
	print(chr(res+ord('A')-1),end="")
```



## jarvis oj

### xyf

已知e,n,c

用yafu分解(factor(  $n ))得到p,q

```python
import gmpy2
import gmpy
from Crypto.Util.number import *
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5

p=56225103425920179745019828423382255030086226600783237398582720244250840205090747144995470046432814267877822949968612053620215667790366338413979256357713975498764498045710766375614107934719809398451422359883451257033337168560937824719275885709824193760523306327217910106187213556299122895037021898556005848927
q=56225103425920179745019828423382255030086226600783237398582720244250840205090747144995470046432814267877822949968612053620215667790366338413979256357713975498764498045710766375614107934719809398451422359883451257033337168560937824719275885709824193760523306327217910106187213556299122895037021898556005848447
e=65537
ans = 1
phin=(p-1)*(q-1)
d=gmpy2.invert(e,phin)

c=631583911592660652215412683088688785438938386403323323131247534561958531288570612134139288090533619548876156447498627938626419617968918299212863936839701943643735437264304062828205809984533592547599060829451668240569384130130080928292082888526567902695707215660020201392640388518379063244487204881439591813398495285025704285781072987024698133147354238702861803146548057736756003294248791827782280722670457157385205787259979804892966529536902959813675537028879407802365439024711942091123058305460856676910458268097798532901040050506906141547909766093323197363034959926900440420805768716029052885452560625308314284406
N=3161262255255421133292506694323988711204792818702640666084331634444148712428915950639954540974469931426618702044672318134908678730641981414037034058320359158246813987154679178159391832232990193738454116371045928434239936027006539348488316754611586659587677659791620481200732564068367148541242426533823626586574915275209508300120574819113851895932912208783915652764568319771482309338434364094681579135086703127977870534715039005822312878739611630155714313119545610939253355808742646891815442758660278514976431521933763272615653261044607041876212998883732724662410197038419721773290601109065965674129599626151139566369
flag = gmpy2.powmod(c, d, N)
print hex(flag)[2:].decode('hex')
```



## buuoj

### rsa

```python
import gmpy2
p=473398607161
q=4511491
e=17
print gmpy2.invert(17,(p-1)*(q-1))
```





### rsarsa

这题考我们是否会解密rsa

```python
import gmpy2
from Crypto.Util.number import long_to_bytes
p=9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483
q=11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407
e=65537
c=83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034
phin=(p-1)*(q-1)
N=p*q
d=gmpy2.invert(e, phin)
print (gmpy2.powmod(c, d, N))
```



### rsa1

#### 已知p,q,dp,dq,c求m



 https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Using_the_Chinese_remainder_algorithm 



```python
import gmpy2
from Crypto.Util.number import long_to_bytes
def dec(dp,dq,p,q,c):
	qinv=gmpy2.invert(q,p)
	m1=pow(c,dp,p)
	m2=pow(c,dq,q)
	h=(qinv*(m1-m2))%p
	return m2+h*q
		
			

p=8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 
q=12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 
dp=6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 
dq=783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 
c=24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852

n=p*q
phin=(p-1)*(q-1)

print long_to_bytes(dec(dp,dq,p,q,c))


```



### rsa3

共模攻击

```python
from Crypto.Util.number import long_to_bytes,bytes_to_long,getPrime,isPrime
import primefac
def same_n_sttack(n,e1,e2,c1,c2):
    def egcd(a, b):
        x, lastX = 0, 1
        y, lastY = 1, 0
        while (b != 0):
            q = a // b
            a, b = b, a % b
            x, lastX = lastX - q * x, x
            y, lastY = lastY - q * y, y
        return (lastX, lastY)

    s = egcd(e1, e2)
    s1 = s[0]
    s2 = s[1]
    if s1<0:
        s1 = - s1
        c1 = primefac.modinv(c1, n)
        if c1<0:
            c1+=n
    elif s2<0:
        s2 = - s2
        c2 = primefac.modinv(c2, n)
        if c2<0:
            c2+=n
    m=(pow(c1,s1,n)*pow(c2,s2,n)) % n
    return m

c1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361
n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801
e1=11187289
c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397
e2=9647291
print long_to_bytes(same_n_sttack(n,e1,e2,c1,c2))


```

