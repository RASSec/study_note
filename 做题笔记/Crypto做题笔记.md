# Crypto做题笔记

## 攻防世界

### 你猜猜

##### 解题思路



题目提供文件

haha.txt

```
504B03040A0001080000626D0A49F4B5091F1E0000001200000008000000666C61672E7478746C9F170D35D0A45826A03E161FB96870EDDFC7C89A11862F9199B4CD78E7504B01023F000A0001080000626D0A49F4B5091F1E00000012000000080024000000000000002000000000000000666C61672E7478740A0020000000000001001800AF150210CAF2D1015CAEAA05CAF2D1015CAEAA05CAF2D101504B050600000000010001005A000000440000000000
```

看别人的wp知道了504B0304是Zip的文件头

HxD新建文件，将`haha.txt`中的数据copy进去，命名为`1.zip`

压缩文件需要密码直接爆破(工具:ziperello)

##### 收获

zip的文件头:504B0304

工具:HxD,ziperello(破解压缩文件密码)

### 告诉你个秘密

### 思路

题目给你两个字符串

>636A56355279427363446C4A49454A7154534230526D6843
>56445A31614342354E326C4B4946467A5769426961453067

尝试看成hex编码,试一下

得到

>cjV5RyBscDlJIEJqTSB0RmhC
>
>VDZ1aCB5N2lKIFFzWiBiaE0g

尝试base64decode

>r5yG lp9I BjM tFhB
>T6uh y7iJ QsZ bhM 

到这边就是我会做的全部了

试了一堆最后百度发现

你妈是看键盘

> 在键盘上`r5yg`中间的字母是`t`,同理，将其他的也找出来，得到
>
> TONGYUAN



### **Easy-one**


  做这题的时候我没有事先进行分析，一直以为密钥是CENSORED

看了别人的wp才发现这题的密钥不是CENSORED。





msg001.enc是msg001的加密文件,已知过程直接逆向出密钥。

贴上代码

```c
//获取密钥
#define false 0
#define true 1
int main() {
	FILE* input  = fopen("msg001", "rb");
	FILE* output = fopen("msg001.enc", "rb");
	if (!input || !output) {
		printf("Error\n");
		return 0;
	}
	int c, p, t = 0;
	char k[30]="";
	int i = 0;
	while ((p = fgetc(input)) != EOF &&(c= fgetc(output))!=EOF  ) {
		char ch;
		//(p + (k[i % strlen(k)] ^ t) + i*i) & 0xff;
		int ok=false;
		while(1)
		{
			for(ch=32;ch<127;ch++)
			{
				printf("未加密:%d,测试加密:%d,正确加密:%d,猜测k:%d\n",p,(p + (ch ^ t) + i*i) & 0xff,c,ch);
				if((p + (ch ^ t) + i*i) == c)
				{
					ok=true;
					break;
				}
			}
			if(ok)
				break;
			else c+=256;
		
		}
		
			
		k[i]=ch;
		t = p;
		i++;
	}
	k[i+1]=0;
	printf("%s",k);
	return 0;
}


//解密
int main() {

	FILE* input  = fopen("msg002.enc", "rb");
	char k[] = "VeryLongKeyYouWillNeverGuess";
	char c, p, t = 0;
	int i = 0;
	while ((p = fgetc(input)) != EOF) {
		 
		//(p + (k[i % strlen(k)] ^ t) + i*i) & 0xff;
		c = (p-i*i-(k[i % strlen(k)] ^ t));
		t = c;
		i++;
		printf("%c",c);
	}
	return 0;
}
```



### 幂数加密(云影密码)

• 云影密码仅包含01248五个数字，其中0用于分割，其余数字用于
做和之后转换为明文

```python

s="8842101220480224404014224202480122"
s=s.split("0")
print(s)
for i in s:
	res=0
	for j in i:
		res+=int(j)
	print(chr(res+ord('A')-1),end="")
```



## jarvis oj

### xyf

已知e,n,c

用yafu分解(factor(  $n ))得到p,q

```python
import gmpy2
import gmpy
from Crypto.Util.number import *
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5

p=56225103425920179745019828423382255030086226600783237398582720244250840205090747144995470046432814267877822949968612053620215667790366338413979256357713975498764498045710766375614107934719809398451422359883451257033337168560937824719275885709824193760523306327217910106187213556299122895037021898556005848927
q=56225103425920179745019828423382255030086226600783237398582720244250840205090747144995470046432814267877822949968612053620215667790366338413979256357713975498764498045710766375614107934719809398451422359883451257033337168560937824719275885709824193760523306327217910106187213556299122895037021898556005848447
e=65537
ans = 1
phin=(p-1)*(q-1)
d=gmpy2.invert(e,phin)

c=631583911592660652215412683088688785438938386403323323131247534561958531288570612134139288090533619548876156447498627938626419617968918299212863936839701943643735437264304062828205809984533592547599060829451668240569384130130080928292082888526567902695707215660020201392640388518379063244487204881439591813398495285025704285781072987024698133147354238702861803146548057736756003294248791827782280722670457157385205787259979804892966529536902959813675537028879407802365439024711942091123058305460856676910458268097798532901040050506906141547909766093323197363034959926900440420805768716029052885452560625308314284406
N=3161262255255421133292506694323988711204792818702640666084331634444148712428915950639954540974469931426618702044672318134908678730641981414037034058320359158246813987154679178159391832232990193738454116371045928434239936027006539348488316754611586659587677659791620481200732564068367148541242426533823626586574915275209508300120574819113851895932912208783915652764568319771482309338434364094681579135086703127977870534715039005822312878739611630155714313119545610939253355808742646891815442758660278514976431521933763272615653261044607041876212998883732724662410197038419721773290601109065965674129599626151139566369
flag = gmpy2.powmod(c, d, N)
print hex(flag)[2:].decode('hex')
```



## buuoj

### rsa

```python
import gmpy2
p=473398607161
q=4511491
e=17
print gmpy2.invert(17,(p-1)*(q-1))
```





### rsarsa

这题考我们是否会解密rsa

```python
import gmpy2
from Crypto.Util.number import long_to_bytes
p=9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483
q=11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407
e=65537
c=83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034
phin=(p-1)*(q-1)
N=p*q
d=gmpy2.invert(e, phin)
print (gmpy2.powmod(c, d, N))
```



### rsa1

#### 已知p,q,dp,dq,c求m



 https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Using_the_Chinese_remainder_algorithm 



```python
import gmpy2
from Crypto.Util.number import long_to_bytes
def dec(dp,dq,p,q,c):
	qinv=gmpy2.invert(q,p)
	m1=pow(c,dp,p)
	m2=pow(c,dq,q)
	h=(qinv*(m1-m2))%p
	return m2+h*q
		
			

p=8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 
q=12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 
dp=6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 
dq=783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 
c=24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852

n=p*q
phin=(p-1)*(q-1)

print long_to_bytes(dec(dp,dq,p,q,c))


```



### rsa3

共模攻击

```python
from Crypto.Util.number import long_to_bytes,bytes_to_long,getPrime,isPrime
import primefac
def same_n_sttack(n,e1,e2,c1,c2):
    def egcd(a, b):
        x, lastX = 0, 1
        y, lastY = 1, 0
        while (b != 0):
            q = a // b
            a, b = b, a % b
            x, lastX = lastX - q * x, x
            y, lastY = lastY - q * y, y
        return (lastX, lastY)

    s = egcd(e1, e2)
    s1 = s[0]
    s2 = s[1]
    if s1<0:
        s1 = - s1
        c1 = primefac.modinv(c1, n)
        if c1<0:
            c1+=n
    elif s2<0:
        s2 = - s2
        c2 = primefac.modinv(c2, n)
        if c2<0:
            c2+=n
    m=(pow(c1,s1,n)*pow(c2,s2,n)) % n
    return m

c1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361
n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801
e1=11187289
c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397
e2=9647291
print long_to_bytes(same_n_sttack(n,e1,e2,c1,c2))


```



## rois

### easyrsa

```python
flag='xxxxxx'

from Crypto.Util.number import getPrime,bytes_to_long
p=getPrime(1024)
q=getPrime(1024)
e=65537
n=p*q
m=bytes_to_long(flag)
c=pow(m,e,n)
print c,e,n

p=getPrime(1024)
e=65537
n=p*q
m=bytes_to_long("1"*32)
c=pow(m,e,n)
print c,e,n
#q相同
# c=8663442081613118775974515568199513076483297026441021965930306759418199635348451596714404459237243047214659906702514151756915605968026981959304166737213445887236031531619191200317205129190367553146805919805690889403844728709350292969162642899898963207011182370071925871894093500648562548903846130900275651491259665402748842299555389325745132220737609707469437099704314540767892238808929589104451430649267031260486537800287467420283557120560101805158644418888266324955479594576254252847002740964564201175232258967891241554083619030612548048215550489876470299867303272213471726402801137135808234821647821609234902053799
# e=65537 
# n=21453707540987261169124353576279273447046449190618455950514683231403855329899800512219160163141058176948206118779178404032841424811464684953351841961581184620414807317292317693409106592785157687951184224578654281512342080714015600229766187636759006063345380921740463319862249098170403829734122827496987261254574592477152493609740412086991410681831229975263562992222479632231373874347442548646629618718569959255055434746486092542032338659561721459477703663368375416409431294663210636082591592312647802781421535085946412431815911782404995927042505875080089209034931833613455745908391905021469379337769821109002925274907
# c=6007436694062663634050061048945941219517196439354935169568621898210594097444906093007389592646204668034031374982960972309843481091792240635286636580509915416833946900875120790387876318791452228931595589014894901273443985334028493106250697120869965216690903354510278790479322001639160547689360482031010005912388006437282684334334298376664393881184522670495667372583403258065221660813853965869505232254326007743279079349457923081173729789866581015931543961219751439217011942647771566559069582290890786282799392544925789949036672658429603105440224067721885447375119210213226708857366974050772768789324271912282322886674
# e=65537
# n=18598614196832001177771468864213515937765452037882702650385784226737748820026828912830753017468804844101427687773702042440578156864241748194698057082239147558971300198021067156117406950227148425843860288344251784348217515784361679796194180139559087091632869898338762991227148480539814512237673161619721899001938837090033217673023552934226140689402193153911762839688194940176652707819193733772033224471132081948852875182095633798180030064703518832439714564507081834279727733472219043182164547156004569017386771668362515893849525953457455534839207479715689271217346673018164240308691943262598128901642524353258508353299
# m=22250244598543112061784228491865519548275408818103480933072241632893111185713
#p1,p2 
```

观察发现第一个和第二个的q都相同，而且第二个的密文明文都知道。所以刚开始的时候我想的是通过逆解密过程来得到d,再得到phin,最后通过phin得到p,q,后来和学长讨论了一下发现这个思路不太行



后来学长提示我欧几里得算法,我差不到就明白了

`p1*q1=N1`,`p2*q2=N2`,因为q1,q2相同,n1,n2已知，并且p,q都是质数，也就是说gcd(n1,n2)求出的最大公约数就是q,知道q就可以求出p



最后的脚本

```python
from Crypto.Util.number import long_to_bytes,bytes_to_long,getPrime,isPrime
from gmpy2 import *

n1=21453707540987261169124353576279273447046449190618455950514683231403855329899800512219160163141058176948206118779178404032841424811464684953351841961581184620414807317292317693409106592785157687951184224578654281512342080714015600229766187636759006063345380921740463319862249098170403829734122827496987261254574592477152493609740412086991410681831229975263562992222479632231373874347442548646629618718569959255055434746486092542032338659561721459477703663368375416409431294663210636082591592312647802781421535085946412431815911782404995927042505875080089209034931833613455745908391905021469379337769821109002925274907
n2=18598614196832001177771468864213515937765452037882702650385784226737748820026828912830753017468804844101427687773702042440578156864241748194698057082239147558971300198021067156117406950227148425843860288344251784348217515784361679796194180139559087091632869898338762991227148480539814512237673161619721899001938837090033217673023552934226140689402193153911762839688194940176652707819193733772033224471132081948852875182095633798180030064703518832439714564507081834279727733472219043182164547156004569017386771668362515893849525953457455534839207479715689271217346673018164240308691943262598128901642524353258508353299

q=gcd(n1,n2)
p=n1/q
phin=(p-1)*(q-1)
e=65537
d = invert(e, phin)
c=8663442081613118775974515568199513076483297026441021965930306759418199635348451596714404459237243047214659906702514151756915605968026981959304166737213445887236031531619191200317205129190367553146805919805690889403844728709350292969162642899898963207011182370071925871894093500648562548903846130900275651491259665402748842299555389325745132220737609707469437099704314540767892238808929589104451430649267031260486537800287467420283557120560101805158644418888266324955479594576254252847002740964564201175232258967891241554083619030612548048215550489876470299867303272213471726402801137135808234821647821609234902053799
print long_to_bytes(powmod(c, d, n1))

```





### easylfsr

题目

```python
import base64
flag = "flag{xxxxxxxxxxxx}"

def lfsr(R,mask):
    output = (R << 1) & 0xffffff
    i=(R&mask)&0xffffff
    lastbit=0
    while i!=0:
        lastbit^=(i&1)
        i=i>>1
    output^=lastbit
    return (output,lastbit)

secret = ''
R=int(flag[5:-1],2)
print(R)
mask = 0b1010011000100011100

for i in range(12):
    tmp=0
    for j in range(8):
        (R,out)=lfsr(R,mask)
        tmp=(tmp << 1)^out
    secret+=chr(tmp)
secret=bytes(secret,encoding="utf8")
print(base64.b64encode(secret))

# 输出结果为:b'ZMOiLXDCr2fCg397a1TDsw=='
```

#### 思路

##### 如果二进制很小直接爆破



阅读代码很容易发现flag中间的数据是明显小等24位的



`2^24=16777216`

最坏的情况也就尝试1000万次,可以尝试一下

后来跑了3000次就拿到flag了.......

规规矩矩解密

#### 代码分析

##### lfsr

```python
def lfsr(R,mask):
    output = (R << 1) & 0xffffff
    i=(R&mask)&0xffffff
    lastbit=0
    while i!=0:
        lastbit^=(i&1)
        i=i>>1
    output^=lastbit
    return (output,lastbit)

```



lfsr函数中,返回值output被限制在24位,`output = (R << 1) & 0xffffff`

也就是说经过大于数次移位后数据会丢失

但是继续阅读代码发现lastbit可以校验i的第19位的值(如果前面18位的值正确),而i的第19位的值恰好是R第19位的值.

也就是说如果解密函数中传入参数OUTPUT值的第19位是错误的，是可以检测出来的



` output = (R << 1) & 0xffffff  ` 

`output^=lastbit`

经过一定次数的右移后，output将是由lastbit组成的数



##### 加密过程

```python
for i in range(12):
    tmp=0
    for j in range(8):
        (R,out)=lfsr(R,mask)
        tmp=(tmp << 1)^out
    secret+=chr(tmp)
secret=bytes(secret,encoding="utf8")
print(base64.b64encode(secret))

```



tmp是由8位lastbit组成的值

因此我们可以推断出最后一个output位secret[-3],secret[-2],secret[-1]组成的值

结合lfsr函数的特性,利用lastbit检测第19位是否正确来逆推出flag(flag小于19位)



解密脚本

```python
import base64
flag="flag{111010111001}"#111010111001
out_arr=[]
re_out_arr=[]
last_bit_arr=[]
re_last_bit_arr=[]
def lfsr(R,mask):
    output = (R << 1) & 0xffffff#..........................0
    i=(R&mask)&0xffffff
    lastbit=0#0,1
    while i!=0:
        lastbit^=(i&1)
        i=i>>1
    output^=lastbit
    #print(lastbit,end="")
    out_arr.append(output)
    last_bit_arr.append(lastbit)
    return (output,lastbit)
def get_lastbit(R):
    mask=0b1010011000100011100
    i=(R&mask)&0xffffff
    lastbit=0#0,1
    while i!=0:
        lastbit^=(i&1)
        i=i>>1
    return lastbit
def check(guess,real_lastbit):
    R=guess
    lastbit=get_lastbit(R)
    return lastbit==real_lastbit

def delfsr(output,lastbit):
    re_out_arr.append(output)
    re_last_bit_arr.append(lastbit)
    output^=lastbit
    mask=0b1010011000100011100
    R=(output>>1)& 0xffffff
    if check(R,lastbit):
        return (R,mask)
    else:
        return (R+(1<<18),mask)



def enc(flag):
    secret = ''
    R=int(flag[5:-1],2)
    mask = 0b1010011000100011100

    for i in range(12):
        tmp=0
        for j in range(8):
            (R,out)=lfsr(R,mask)
            tmp=(tmp << 1)^out
        secret+=chr(tmp)
    secret=bytes(secret,encoding="utf8")
    return base64.b64encode(secret)
def dec(res):
    R=((ord(res[len(res)-3])&0xff)<<16)+((ord(res[len(res)-2])&0xff)<<8)+((ord(res[len(res)-1])&0xff))

    for i in range(12):
        for j in range(8):
            #print(R)
            (R,mask)=delfsr(R,(ord(res[len(res)-1-i])>>j)&(1))
    
    return (bin(R))[2:]
r=(enc(flag))
res=str(base64.b64decode("ZMOiLXDCr2fCg397a1TDsw=="),encoding="utf8")
print(dec(res))

```









```python
import base64
flag="flag{111010111001}"#111010111001
out_arr=[]
re_out_arr=[]
last_bit_arr=[]
re_last_bit_arr=[]
def lfsr(R,mask):
    output = (R << 1) & 0xffffff#..........................0
    i=(R&mask)&0xffffff
    lastbit=0#0,1
    while i!=0:
        lastbit^=(i&1)
        i=i>>1
    output^=lastbit
    #print(lastbit,end="")
    out_arr.append(output)
    last_bit_arr.append(lastbit)
    return (output,lastbit)
def get_lastbit(R):
    mask=0b1010011000100011100
    i=(R&mask)&0xffffff
    lastbit=0#0,1
    while i!=0:
        lastbit^=(i&1)
        i=i>>1
    return lastbit
def check(guess,real_lastbit):
    R=guess
    lastbit=get_lastbit(R)
    return lastbit==real_lastbit

def delfsr(output,lastbit):
    re_out_arr.append(output)
    re_last_bit_arr.append(lastbit)
    output^=lastbit
    mask=0b1010011000100011100
    R=(output>>1)& 0xffffff
    if check(R,lastbit):
        return (R,mask)
    else:
        return (R+(1<<18),mask)

    # if "111010111001" in bin(R):
    #     print("found",R)
    # else :
    #     print(R)
    #print(output,lastbit)

#(output,lastbit)=>(R,mask)


def enc(flag):
    secret = ''
    R=int(flag[5:-1],2)#0010101101110011
    mask = 0b1010011000100011100

    for i in range(12):
        tmp=0
        for j in range(8):
            (R,out)=lfsr(R,mask)
            tmp=(tmp << 1)^out
        #print(bin(tmp)[2:],end="\n")
        secret+=chr(tmp)
    secret=bytes(secret,encoding="utf8")
    # print(R,out)
    return base64.b64encode(secret)

        # w7ULw6DCvcOdIWjDnsOSaMKBw7E=
def dec(res):
    R=((ord(res[len(res)-3])&0xff)<<16)+((ord(res[len(res)-2])&0xff)<<8)+((ord(res[len(res)-1])&0xff))

    for i in range(12):
        for j in range(8):
            #print(R)
            (R,mask)=delfsr(R,(ord(res[len(res)-1-i])>>j)&(1))
    
    return (bin(R))[2:]
# result=dec(res)
# print(int(result,2))
# print("flag{%s}" % result)
# if enc("flag{%s}" % result)==b"ZMOiLXDCr2fCg397a1TDsw==":
#     print("success")

# for i in range(1<<24):
#     if enc("flag{%s}"%(bin(i)[2:]))==b"ZMOiLXDCr2fCg397a1TDsw==":
#         print("success:",i)
r=(enc(flag))
res=str(base64.b64decode("ZMOiLXDCr2fCg397a1TDsw=="),encoding="utf8")
print(r)
print(dec(res))

out_arr=out_arr[::-1]
print(out_arr)
print(re_out_arr)
last_bit_arr=last_bit_arr[::-1]
print(last_bit_arr)
print(re_last_bit_arr)
print(get_lastbit(0b1010011000100011100))
print(get_lastbit(0b1010011000100011100))
#最后一个R值:7034099
#lastbit[]=011001001110001000101101011100001010111101100111100000110111111101111011011010110101010011110011
#          0110010011100010101101111000010101111110011110000011111111111110111101011101010011110011
#         10110101001101100111111010011001100101100010001001000011111001011001011001101000011110011111001111100111011111000011100011010100100010011100111110111111101111101

```

