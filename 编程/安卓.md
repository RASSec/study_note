# 安卓开发

## 安卓架构

1. Linux 内核层 Android 系统是基于 Linux 2.6 内核的，这一层为 Android 设备的各种硬件提供了底 层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi 驱动、电源管理等。 
2.  系统运行库层 这一层通过一些 C/C++库来为 Android 系统提供了主要的特性支持。如 SQLite 库提 供了数据库的支持，OpenGL|ES 库提供了 3D 绘图的支持，Webkit 库提供了浏览器内核 的支持等。 同样在这一层还有 Android 运行时库，它主要提供了一些核心库，能够允许开发者 使用 Java 语言来编写 Android 应用。另外 Android 运行时库中还包含了 Dalvik 虚拟机， 它使得每一个 Android 应用都能运行在独立的进程当中，并且拥有一个自己的 Dalvik 虚 拟机实例。相较于 Java 虚拟机，Dalvik 是专门为移动设备定制的，它针对手机内存、 CPU 性能有限等情况做了优化处理。 
3.  应用框架层 这一层主要提供了构建应用程序时可能用到的各种 API，Android 自带的一些核心 应用就是使用这些API完成的，开发者也可以通过使用这些API来构建自己的应用程序。 
4.  应用层 所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等 程序，或者是你从 Google Play 上下载的小游戏，当然还包括你自己开发的程序。

![](https://raw.githubusercontent.com/Explorersss/photo/master/20200923161741.png)





## 安卓开发规范

1. 其实 Android程序的设计讲究逻辑和视图分离，因此是不推荐在活动中直接编写界面的， 更加通用的一种做法是，在布局文件中编写界面，然后在活动中引入进来。
2. Android 不 推 荐 在 程 序 中 对 字 符 串 进 行 硬 编 码 ， 更 好 的 做 法 一 般 是 把 字 符 串 定 义 在 res/values/strings.xml 里，然后可以在布局文件或代码中引用。



## 目录结构

app > java > com.example.myfirstapp > MainActivity
这是主 Activity。它是应用的入口点。当您构建和运行应用时，系统会启动此 Activity 的实例并加载其布局。
app > res > layout > activity_main.xml
此 XML 文件定义了 Activity 界面的布局。它包含一个 TextView 元素，其中具有“Hello, World!”文本
app > manifests > AndroidManifest.xml
清单文件描述了应用的基本特性并定义了每个应用组件。
Gradle Scripts > build.gradle
有两个使用此名称的文件：一个针对项目“Project: My First App”，另一个针对应用模块“Module: app”。

### AndroidManifest.xml

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.example.activitytest"<!-- 指定包名 -->
          android:versionCode="1"
          android:versionName="1.0" >
    <uses-sdk
              android:minSdkVersion="14"
              android:targetSdkVersion="19" />
    <application
                 android:allowBackup="true"
                 android:icon="@drawable/ic_launcher"
                 android:label="@string/app_name"
                 android:theme="@style/AppTheme" >
        <activity
                  android:name=".FirstActivity"<!-- com.example.activitytest.FirstActivity 的缩写 -->
                  android:label="This is FirstActivity" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter><!--让 FirstActivity 作为我们这个程序的
主活动，即点击桌面应用程序图标时首先打开的就是这个活动-->
        </activity>
    </application>
</manifest>
```

这段代码表示对 HelloWorldActivity 这个活动进行注册，没有在 AndroidManifest.xml 里 注册的活动是不能使用的。其中 intent-filter 里的两行代码非常重要，`<action android:name=
"android.intent.action.MAIN" />和<category android:name="android.intent.category.LAUNCHER" />` 表示 HelloWorldActivity 是这个项目的主活动，在手机上点击应用图标，首先启动的就是这 个活动。

### res

drawable开头的文件夹都是用来放图片的，所有以 values开头的文件夹都是用来放字符串的， layout 文件夹是用来放布局文件的，menu 文件夹是用来放菜单文件的。




### res/layout



## 开发技巧



### 引用资源

在 strings.xml 中找到的 Hello world!字符串，我们有两种方式可以引用它： 

1. 在代码中通过 R.string.hello_world 可以获得该字符串的引用；
2.  XML 中通过@string/hello_world 可以获得该字符串的引用。

基本的语法就是上面两种方式，其中 string 部分是可以替换的，如果是引用的图片资源 就可以替换成 drawable，如果是引用的布局文件就可以替换成 layout，以此类推。



如果你需要在 XML 中引用一个 id，就使用@id/id_name 这种语法，而如果你需要在 XML 中 定义一个 id，则要使用@+id/id_name 这种语法。



### 日志工具

Android 中的日志工具类是 Log（android.util.Log），这个类中提供了如下几个方法来供我们打印日志。 

1. Log.v() 这个方法用于打印那些最为琐碎的，意义最小的日志信息。对应级别 verbose，是 Android 日志里面级别最低的一种。 
2.  Log.d() 这个方法用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助 的。对应级别 debug，比 verbose 高一级。
3. Log.i() 这个方法用于打印一些比较重要的数据，这些数据应该是你非常想看到的，可以帮 你分析用户行为的那种。对应级别 info，比 debug 高一级。 
4.  Log.w() 这个方法用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好 去修复一下这些出现警告的地方。对应级别 warn，比 info 高一级。 
5.  Log.e() 这个方法用于打印程序中的错误信息，比如程序进入到了 catch 语句当中。当有错 误信息打印出来的时候，一般都代表你的程序出现严重问题了，必须尽快修复。对应级 别 error，比 warn 高一级。



## 活动Activity

### Activity class

它是一种可以包含用户界面的组件， 主要用于和用户进行交互

```java

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}
```

onCreate()方法是一个活动被创建时必定要执行的方法

#### 方法汇总

```java
setContentView(R.layout.activity_main);//设置界面
requestWindowFeature(Window.FEATURE_NO_TITLE);//启用窗体的扩展特性，隐藏标题栏，注意这句代码一定要在 setContentView()之前执行,只有是Activity子类才生效
findViewById(R.id.button_1);//以通过 findViewById()方法获取到在布局文件中定义的元素
finish();//销毁活动
```



### Toast

![](https://raw.githubusercontent.com/Explorersss/photo/master/20200923211149.png)



添加监听器

```java
Button button1 = (Button) findViewById(R.id.button_1);
button1.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick(View v) {
        Toast.makeText(FirstActivity.this, "You clicked Button 1",
                       Toast.LENGTH_SHORT).show();
    }
});
```



### 添加menu

首先在 res 目录下新建一个 menu 文件夹

```xml
<menu xmlns:android="http://schemas.android.com/apk/res/android" >
    <item
          android:id="@+id/add_item"
          android:title="Add"/>
    <item
          android:id="@+id/remove_item"
          android:title="Remove"/>
</menu>
```

重写Activity 中的 onCreateOptionsMenu 方法

```java
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
}
```



添加处理函数

```java
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.add_item:
            Toast.makeText(this, "You clicked Add", Toast.LENGTH_SHORT).show();
            break;
        case R.id.remove_item:
            Toast.makeText(this, "You clicked Remove", Toast.LENGTH_SHORT).show();
            break;
        default:
    }
    return true;
}
```



## 编写程序界面

android:layout_width 指定了 控件的宽度，android:layout_height 指定了控件的高度。Android 中所有的控件都具有这 两个属性，可选值有三种 match_parent、fill_parent 和 wrap_content，其中 match_parent 和 fill_parent 的意义相同，现在官方更加推荐使用 match_parent。match_parent 表示让当前控件的大小和父布局的大小一样，也就是由父布局来决定当前控件的大小。wrap_content 表示让 当前控件的大小能够刚好包含住里面的内容，也就是由控件内容决定当前控件的大小。



所有的 Android控件都具有这个属性，可以通过 android:visibility 进行指定，可选值有三种，visible、invisible 和 gone。

相关代码

`progressBar.setVisibility(View.VISIBLE);`



### 常见控件

#### TextView

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:orientation="vertical" >
    <TextView
              android:id="@+id/text_view"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:gravity="center"<!--指定文字对齐方式，可选值有 top、bottom、left、right、center等 ，可以用 “ | ”来同时指定多个值-->
            android:textSize="24sp"
            android:textColor="#00ff00"
            android:text="This is TextView" />
</LinearLayout>
```



#### Button

```xml
<Button
        android:id="@+id/button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Button" />
```

注册监听器

```java
public class MainActivity extends Activity {
    private Button button;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                // 在此处添加逻辑
            }
        });
    }
}
```

如果你不喜欢使用匿名类的方式来注册监听器，也可以使用实现接 口的方式来进行注册



```java
public class MainActivity extends Activity implements OnClickListener {
    private Button button;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        button = (Button) findViewById(R.id.button);
        button.setOnClickListener(this);
    }
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.button:
                // 在此处添加逻辑
                break;
            default:
                break;
        }
    }
}
```



#### EditText



```xml
<EditText
          android:id="@+id/edit_text"
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          android:hint="Type something here"<!-- 提示 -->
		  android:maxLines="2" <!-- 指定了 EditText 的最大行数为两行 -->
		  android:drawableLeft="@drawable/user_name_icon" <!-- 在左侧绘制图片-->
          />
```



```java
editText = (EditText) findViewById(R.id.edit_text);
String inputText = editText.getText().toString();
```



#### ImageView

```xml
<ImageView
           android:id="@+id/image_view"
           android:layout_width="wrap_content"
           android:layout_height="wrap_content"
           android:src="@drawable/ic_launcher"
           />
```



```java
imageView = (ImageView) findViewById(R.id.image_view);
imageView.setImageResource(R.drawable.jelly_bean);
```



#### ProgressBar

![](https://raw.githubusercontent.com/Explorersss/photo/master/20200923215733.png)

```xml
<ProgressBar
             android:id="@+id/progress_bar"
             android:layout_width="match_parent"
             android:layout_height="wrap_content"
             />
```

通过 style 属性 可以将它指定成水平进度条

添加属性：

```xml
style="?android:attr/progressBarStyleHorizontal"
android:max="100"
```

在代码中动态地更改进度条的进度

```java
public void onClick(View v) {
    switch (v.getId()) {
        case R.id.button:
            int progress = progressBar.getProgress();
            progress = progress + 10;
            progressBar.setProgress(progress);
            break;
        default:
            break;
    }
}
```

#### AlertDialog

```java
public class MainActivity extends Activity implements OnClickListener { ……
    @Override
    public void onClick(View v) {
    switch (v.getId()) {
        case R.id.button:
            AlertDialog.Builder dialog = new AlertDialog.Builder
                (MainActivity.this);
            dialog.setTitle("This is Dialog");
            dialog.setMessage("Something important.");
            dialog.setCancelable(false);
            dialog.setPositiveButton("OK", new DialogInterface.
                                     OnClickListener() {
                                         @Override
                                         public void onClick(DialogInterface dialog, int which) {
                                         }
                                     });
            dialog.setNegativeButton("Cancel", new DialogInterface.
                                     OnClickListener() {
                                         @Override
                                         public void onClick(DialogInterface dialog, int which) {
                                         }
                                     });
            dialog.show();
            break;
        default:
            break;
    }
}
                                                                      }
```



#### ProgressDialog

ProgressDialog 会在对话框中显示一个进度条，一般是 用于表示当前操作比较耗时，让用户耐心地等待

```java
public class MainActivity extends Activity implements OnClickListener { ……
    @Override
    public void onClick(View v) {
    switch (v.getId()) {
        case R.id.button:
            ProgressDialog progressDialog = new ProgressDialog
                (MainActivity.this);
            progressDialog.setTitle("This is ProgressDialog");
            progressDialog.setMessage("Loading...");
            progressDialog.setCancelable(true);//如果在 setCancelable()中传入了 false，表示 ProgressDialog 是不能通过 Back 键取消掉的当数据加载完成后必须要调用 ProgressDialog 的dismiss()方法来关闭对话框，否则 ProgressDialog 将会一直存在
            progressDialog.show();
            break;
        default:
            break;
    }
}
                                                                      }
```



### 常用属性



#### layout_weight



**android:layout_weight** 允许我们使用比例的方式来指定控件的大小，它在手机屏幕的适配性方面可以起到非常重要 的作用

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:orientation="horizontal" >
    <EditText
              android:id="@+id/input_message"
              android:layout_width="0dp"
              android:layout_height="wrap_content"
              android:layout_weight="1"
              android:hint="Type something"
              />
    <Button
            android:id="@+id/send"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Send"
            />
</LinearLayout>
```



将 EditText 和 Button 的宽度都指定成了 0,由于我们使用了 android:layout_weight 属性,此时控件的宽度 就不应该再由 android:layout_width 来决定，这里指定成 0 是一种比较规范的写法

后我们在 EditText 和 Button 里都将 android:layout_weight 属性的值指定为 1，这表示 EditText 和 Button 将在水平方向平分宽度.系统会先把 LinearLayout 下所有控件指定的 layout_weight 值相加，得到一个总值， 然后每个控件所占大小的比例就是用该控件的 layout_weight 值除以刚才算出的总值。



仅指定了 EditText 的 android:layout_weight 属性，并将 Button 的宽度改回 wrap_content。这表示 Button 的宽度仍然按照 wrap_content 来计算，而 EditText 则会占满屏 幕所有的剩余空间。使用这种方式编写的界面，不仅在各种屏幕的适配方面会非常好，而且 看起来也更加舒服，重新运行程序，效果如图 3.20 所示

![](https://raw.githubusercontent.com/Explorersss/photo/master/20200923225153.png)





### 常用布局



#### LinearLayout

LinearLayout 称作线性布局，这 个布局会将它所包含的控件在线性方向上依次排列

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:orientation="vertical" >
</LinearLayout>
```

通过 android:orientation来指定是水平还是垂直布局

如果 LinearLayout 的排列方向是 horizontal，内部的控件就绝对不能将 宽度指定为 match_parent，因为这样的话单独一个控件就会将整个水平方向占满。如果 LinearLayout 的排列方向是 vertical，内部的控件就不能将高度指定为 match_parent。

**android:layout_gravity** 属性 用于指定控件在布局中的对齐 方 式



#### RelativeLayout

RelativeLayout 称作相对布局，RelativeLayout 显得更加随意一些，它可以通过相对定位的方式让控件出现在布局 的任何位置。



```xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:layout_width="match_parent"
                android:layout_height="match_parent" >
    <Button
            android:id="@+id/button1"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentLeft="true"
            android:layout_alignParentTop="true"
            android:text="Button 1" />
    <Button
            android:id="@+id/button2"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentRight="true"
            android:layout_alignParentTop="true"
            android:text="Button 2" />
    <Button
            android:id="@+id/button3"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_centerInParent="true"
            android:text="Button 3" />
    <Button
            android:id="@+id/button4"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentBottom="true"
            android:layout_alignParentLeft="true"
            android:text="Button 4" />
    <Button
            android:id="@+id/button5"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentBottom="true"
            android:layout_alignParentRight="true"
            android:text="Button 5" />
</RelativeLayout>
```

![](https://raw.githubusercontent.com/Explorersss/photo/master/20200923225334.png)





```xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:layout_width="match_parent"
                android:layout_height="match_parent" >
    <Button
            android:id="@+id/button3"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_centerInParent="true"
            android:text="Button 3" />
    <Button
            android:id="@+id/button1"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_above="@id/button3"
            android:layout_toLeftOf="@id/button3"
            android:text="Button 1" />
    <Button
            android:id="@+id/button2"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_above="@id/button3"
            android:layout_toRightOf="@id/button3"
            android:text="Button 2" />
    <Button
            android:id="@+id/button4"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_below="@id/button3"
            android:layout_toLeftOf="@id/button3"
            android:text="Button 4" />
    <Button
            android:id="@+id/button5"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_below="@id/button3"
            android:layout_toRightOf="@id/button3"
            android:text="Button 5" />
</RelativeLayout>
```

android:layout_above 属性可以让 一个控件位于另一个控件的上方，需要为这个属性指定相对控件 id 的引用，这里我们填入 了 @id/button3， 表 示 让 该 控 件 位 于 Button 3 的 上 方 。 其 他 的 属 性 也 都 是 相 似 的 ， android:layout_below 表示让一个控件位于另一个控件的下方，android:layout_toLeftOf 表示让 一个控件位于另一个控件的左侧，android:layout_toRightOf 表示让一个控件位于另一个控件 的右侧。**注意，当一个控件去引用另一个控件的 id 时，该控件一定要定义在引用控件的后 面，不然会出现找不到 id 的情况。**

![](https://raw.githubusercontent.com/Explorersss/photo/master/20200923225431.png)



RelativeLayout 中还有另外一组相对于控件进行定位的属性，android:layout_alignLeft 表 示让一个控件的左边缘和另一个控件的左边缘对齐，android:layout_alignRight 表示让一个控件的右边缘和另一个控件的右边缘对齐，还有 android:layout_alignTop 和 android:layout_ alignBottom

#### FrameLayout

这种 布局没有任何的定位方式，所有的控件都会摆放在布局的左上角

```xml
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
             android:layout_width="match_parent"
             android:layout_height="match_parent"
             >
    <Button
            android:id="@+id/button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Button"
            />
    <ImageView
               android:id="@+id/image_view"
               android:layout_width="wrap_content"
               android:layout_height="wrap_content"
               android:src="@drawable/ic_launcher"
               />
</FrameLayout>
```

![](https://raw.githubusercontent.com/Explorersss/photo/master/20200923225549.png)

由于图片是在按钮之后添加的，因此图 片压在了按钮的上面。



#### TableLayout

TableLayout 允许我们使用表格的方式来排列控件

在设计表格时我们 尽量应该让每一行都拥有相同的列数，这样的表格也是最简单的。不过有时候事情并非总会 顺从我们的心意，当表格的某行一定要有不相等的列数时，就需要通过合并单元格的方式来 应对。

```xml
<TableLayout xmlns:android="http://schemas.android.com/apk/res/android"
             android:layout_width="match_parent"
             android:layout_height="match_parent" 
             android:stretchColumns="1"
             >
    <TableRow>
        <TextView
                  android:layout_height="wrap_content"
                  android:text="Account:" />
        <EditText
                  android:id="@+id/account"
                  android:layout_height="wrap_content"
                  android:hint="Input your account" />
    </TableRow>
    <TableRow>
        <TextView
                  android:layout_height="wrap_content"
                  android:text="Password:" />
        <EditText
                  android:id="@+id/password"
                  android:layout_height="wrap_content"
                  android:inputType="textPassword" />
    </TableRow>
    <TableRow>
        <Button
                android:id="@+id/login"
                android:layout_height="wrap_content"
                android:layout_span="2"
                android:text="Login" />
    </TableRow>
</TableLayout>
```

在 TableLayout 中每加入一个 TableRow 就表示在表格中添加了一行，然后在 TableRow 中每加入一个控件，就表示在该行中加入了一列，TableRow 中的控件是不能指定宽度的

第三行只有一列，这样的表格就会很难看，而且 结 构 也 非 常 不 合 理 。 这 时 就 需 要 通 过 对 单 元 格 进 行 合 并 来 解 决 这 个 问 题 ， 使 用 android:layout_span="2"让登录按钮占据两列的空间，就可以保证表格结构的合理性了。

当前的登录界面并没有充分利用屏幕的宽度，右侧还空出了一块 区 域 ， 这 也 难 怪 ， 因 为 在 TableRow 中 我 们 无 法 指 定 控 件 的 宽 度 。 这 时 使 用 android:stretchColumns 属性就可以很好地解决这个问题，它允许将 TableLayout 中的某一列 进行拉伸，以达到自动适应屏幕宽度的作用。

指定成 1 就是拉伸第二列，指定成 0 就是拉伸第一列