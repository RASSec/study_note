# 安卓开发

## 安卓架构

1. Linux 内核层 Android 系统是基于 Linux 2.6 内核的，这一层为 Android 设备的各种硬件提供了底 层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi 驱动、电源管理等。 
2.  系统运行库层 这一层通过一些 C/C++库来为 Android 系统提供了主要的特性支持。如 SQLite 库提 供了数据库的支持，OpenGL|ES 库提供了 3D 绘图的支持，Webkit 库提供了浏览器内核 的支持等。 同样在这一层还有 Android 运行时库，它主要提供了一些核心库，能够允许开发者 使用 Java 语言来编写 Android 应用。另外 Android 运行时库中还包含了 Dalvik 虚拟机， 它使得每一个 Android 应用都能运行在独立的进程当中，并且拥有一个自己的 Dalvik 虚 拟机实例。相较于 Java 虚拟机，Dalvik 是专门为移动设备定制的，它针对手机内存、 CPU 性能有限等情况做了优化处理。 
3.  应用框架层 这一层主要提供了构建应用程序时可能用到的各种 API，Android 自带的一些核心 应用就是使用这些API完成的，开发者也可以通过使用这些API来构建自己的应用程序。 
4.  应用层 所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等 程序，或者是你从 Google Play 上下载的小游戏，当然还包括你自己开发的程序。

![](https://raw.githubusercontent.com/Explorersss/photo/master/20200923161741.png)





## 安卓开发规范

1. 其实 Android程序的设计讲究逻辑和视图分离，因此是不推荐在活动中直接编写界面的， 更加通用的一种做法是，在布局文件中编写界面，然后在活动中引入进来。
2. Android 不 推 荐 在 程 序 中 对 字 符 串 进 行 硬 编 码 ， 更 好 的 做 法 一 般 是 把 字 符 串 定 义 在 res/values/strings.xml 里，然后可以在布局文件或代码中引用。



## 目录结构

app > java > com.example.myfirstapp > MainActivity
这是主 Activity。它是应用的入口点。当您构建和运行应用时，系统会启动此 Activity 的实例并加载其布局。
app > res > layout > activity_main.xml
此 XML 文件定义了 Activity 界面的布局。它包含一个 TextView 元素，其中具有“Hello, World!”文本
app > manifests > AndroidManifest.xml
清单文件描述了应用的基本特性并定义了每个应用组件。
Gradle Scripts > build.gradle
有两个使用此名称的文件：一个针对项目“Project: My First App”，另一个针对应用模块“Module: app”。

### AndroidManifest.xml

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.example.activitytest"<!-- 指定包名 -->
          android:versionCode="1"
          android:versionName="1.0" >
    <uses-sdk
              android:minSdkVersion="14"
              android:targetSdkVersion="19" />
    <application
                 android:allowBackup="true"
                 android:icon="@drawable/ic_launcher"
                 android:label="@string/app_name"
                 android:theme="@style/AppTheme" >
        <activity
                  android:name=".FirstActivity"<!-- com.example.activitytest.FirstActivity 的缩写 -->
                  android:label="This is FirstActivity" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter><!--让 FirstActivity 作为我们这个程序的
主活动，即点击桌面应用程序图标时首先打开的就是这个活动-->
        </activity>
    </application>
</manifest>
```

这段代码表示对 HelloWorldActivity 这个活动进行注册，没有在 AndroidManifest.xml 里 注册的活动是不能使用的。其中 intent-filter 里的两行代码非常重要，`<action android:name=
"android.intent.action.MAIN" />和<category android:name="android.intent.category.LAUNCHER" />` 表示 HelloWorldActivity 是这个项目的主活动，在手机上点击应用图标，首先启动的就是这 个活动。

### res

drawable开头的文件夹都是用来放图片的，所有以 values开头的文件夹都是用来放字符串的， layout 文件夹是用来放布局文件的，menu 文件夹是用来放菜单文件的。




### res/layout



## 开发技巧



### 引用资源

在 strings.xml 中找到的 Hello world!字符串，我们有两种方式可以引用它： 

1. 在代码中通过 R.string.hello_world 可以获得该字符串的引用；
2.  XML 中通过@string/hello_world 可以获得该字符串的引用。

基本的语法就是上面两种方式，其中 string 部分是可以替换的，如果是引用的图片资源 就可以替换成 drawable，如果是引用的布局文件就可以替换成 layout，以此类推。



如果你需要在 XML 中引用一个 id，就使用@id/id_name 这种语法，而如果你需要在 XML 中 定义一个 id，则要使用@+id/id_name 这种语法。



### 日志工具

Android 中的日志工具类是 Log（android.util.Log），这个类中提供了如下几个方法来供我们打印日志。 

1. Log.v() 这个方法用于打印那些最为琐碎的，意义最小的日志信息。对应级别 verbose，是 Android 日志里面级别最低的一种。 
2.  Log.d() 这个方法用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助 的。对应级别 debug，比 verbose 高一级。
3. Log.i() 这个方法用于打印一些比较重要的数据，这些数据应该是你非常想看到的，可以帮 你分析用户行为的那种。对应级别 info，比 debug 高一级。 
4.  Log.w() 这个方法用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好 去修复一下这些出现警告的地方。对应级别 warn，比 info 高一级。 
5.  Log.e() 这个方法用于打印程序中的错误信息，比如程序进入到了 catch 语句当中。当有错 误信息打印出来的时候，一般都代表你的程序出现严重问题了，必须尽快修复。对应级 别 error，比 warn 高一级。



## 活动Activity

### Activity class

它是一种可以包含用户界面的组件， 主要用于和用户进行交互

```java

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}
```

**onCreate()方法是一个活动被创建时必定要执行的方法**

#### 自己创建Activity

**onCreate()方法是一个活动被创建时必定要执行的方法**

```java
public class FirstActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
    }
}
```







#### 方法汇总

```java
setContentView(R.layout.activity_main);//设置界面
requestWindowFeature(Window.FEATURE_NO_TITLE);//启用窗体的扩展特性，隐藏标题栏，注意这句代码一定要在 setContentView()之前执行,只有是Activity子类才生效
findViewById(R.id.button_1);//以通过 findViewById()方法获取到在布局文件中定义的元素
finish();//销毁活动
```



### Toast

![](https://raw.githubusercontent.com/Explorersss/photo/master/20200923211149.png)



添加监听器

```java
Button button1 = (Button) findViewById(R.id.button_1);
button1.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick(View v) {
        Toast.makeText(FirstActivity.this, "You clicked Button 1",
                       Toast.LENGTH_SHORT).show();
    }
});
```



### 添加menu

首先在 res 目录下新建一个 menu 文件夹

```xml
<menu xmlns:android="http://schemas.android.com/apk/res/android" >
    <item
          android:id="@+id/add_item"
          android:title="Add"/>
    <item
          android:id="@+id/remove_item"
          android:title="Remove"/>
</menu>
```

重写Activity 中的 onCreateOptionsMenu 方法

```java
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
}
```



添加处理函数

```java
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.add_item:
            Toast.makeText(this, "You clicked Add", Toast.LENGTH_SHORT).show();
            break;
        case R.id.remove_item:
            Toast.makeText(this, "You clicked Remove", Toast.LENGTH_SHORT).show();
            break;
        default:
    }
    return true;
}
```



### 使用 Intent 在活动之间穿梭

Intent 是 Android 程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组 件想要执行的动作，还可以在不同组件之间传递数据。Intent 一般可被用于启动活动、启动 服务、以及发送广播等场景，由于服务、广播等概念你暂时还未涉及，那么本章我们的目光 无疑就锁定在了启动活动上面。

#### 使用显示Intent

Intent 有多个构造函数的重载，其中一个是 Intent(Context packageContext, Class cls)。 这个构造函数接收两个参数，第一个参数 Context 要求提供一个启动活动的上下文，第二个 参数 Class 则是指定想要启动的目标活动。

Activity 类中提供了一个 startActivity()方法，这个方法 是专门用于启动活动的，它接收一个Intent参数，这里我们将构建好的Intent传入**startActivity()**方法就可以启动目标活动了



```java
Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
startActivity(intent);
```



#### 使用隐式 Intent



相比于显式 Intent，隐式 Intent通过action和 category 来匹配合适的活动。

那么如何定义action和 category？

在activity标签下的intent-filter添加action 和 category标签

```xml
<activity android:name=".SecondActivity" >
<intent-filter>
<action android:name="com.example.activitytest.ACTION_START" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```

一个activity下只能有一个action但是category可以有多个



**隐式Intent调用方式**

```java
Intent intent = new Intent("com.example.activitytest.ACTION_START");
startActivity(intent);

```



**隐式Intent调用不仅仅只会调用这个程序的活动还会调用其他程序匹配的活动**

没有设置category默认的category是DEFAULT

添加category的方式

`intent.addCategory("com.example.activitytest.MY_CATEGORY");`



#### 响应http的intent

以在标签中再配置一个标签，用于更精确地指 定当前活动能够响应什么类型的数据。

标签中主要可以配置以下内容。

1. android:scheme 用于指定数据的协议部分，如上例中的 http 部分。 
2.  android:host 用于指定数据的主机名部分，如上例中的 www.baidu.com 部分。 
3.  android:port 用于指定数据的端口部分，一般紧随在主机名之后。 
4.  android:path 用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容。 
5. android:mimeType

用于指定可以处理的数据类型，允许使用通配符的方式进行指定。 只有标签中指定的内容和 Intent 中携带的 Data 完全一致时，当前活动才能够响应 该 Intent

新建 third_layout.xml 布局文件，代码如下

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:orientation="vertical" >
<Button
android:id="@+id/button_3"
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:text="Button 3"
/>
</LinearLayout>
```

然后新建活动 ThirdActivity 继承自 Activity，代码如下：

```java
public class ThirdActivity extends Activity {
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
requestWindowFeature(Window.FEATURE_NO_TITLE);
setContentView(R.layout.third_layout);
}
}
```

在 AndroidManifest.xml 中为 ThirdActivity 进行注册

```xml
<activity android:name=".ThirdActivity" >
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<data android:scheme="http" />
</intent-filter>
</activity>
```

这样点击http协议的url时就会显示ThirdActivity







#### 常用的action和category

正如上面记录的：隐式Intent调用不仅仅只会调用这个程序的活动还会调用其他程序匹配的活动。这里记录一下查用的action和category

##### 浏览器

打开浏览器：



```java
Intent intent = new Intent(Intent.ACTION_VIEW);
intent.setData(Uri.parse("http://www.baidu.com"));
startActivity(intent);
```

 Intent.ACTION_VIEW是一个 Android 系统内置的动作。然后通过 Uri.parse()方法，将一个网址字 符串解析成一个 Uri 对象，再调用 Intent 的 setData()方法将这个 Uri 对象传递进去



这 个方法其实并不复杂，它接收一个 Uri 对象，主要用于指定当前 Intent 正在操作的数据，而 这些数据通常都是以字符串的形式传入到 Uri.parse()方法中解析产生的。

##### 电话拨号界面

```java
button1.setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
Intent intent = new Intent(Intent.ACTION_DIAL);
intent.setData(Uri.parse("tel:10086"));
startActivity(intent);
}
});
```



### 向下一个活动传递数据

FirstActivity 中有一个字符串，现在想把这个字符串传递到SecondActivity 中

FirstActivity：

```java
button1.setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
String data = "Hello SecondActivity";
Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
intent.putExtra("extra_data", data);//设置传递数据
startActivity(intent);
}
});
```

这里我们还是使用显式 Intent 的方式来启动 SecondActivity，并通过 putExtra()方法传递 了一个字符串。注意这里 putExtra()方法接收两个参数，第一个参数是键，用于后面从 Intent 中取值，第二个参数才是真正要传递的数据。

在 SecondActivity 中将传递的数据取出

```java
public class SecondActivity extends Activity {
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
requestWindowFeature(Window.FEATURE_NO_TITLE);
setContentView(R.layout.second_layout);
Intent intent = getIntent();
String data = intent.getStringExtra("extra_data");//取出地址
Log.d("SecondActivity", data);
}
}
```

由于我们传递的是 字符串，所以使用 getStringExtra()方法来获取传递的数据，如果传递的是整型数据，则使用 getIntExtra()方法，传递的是布尔型数据，则使用 getBooleanExtra()方法，以此类推。



### 返回数据给上一个活动(已经废弃)

Activity 中还有一个 startActivityForResult() 方法也是用于启动活动的，但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。

startActivityForResult()方法接收两个参数，第一个参数还是 Intent，第二个参数是请求码，用于在之后的回调中判断数据的来源。

**第一步：调用startActivityForResult来启动活动**

调用SecondActivity的代码

```java
button1.setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
startActivityForResult(intent, 1);
}
});
```

**第二步在结束前设置返回数据**

活动结束时的设置

```java
Intent intent = new Intent();
intent.putExtra("data_return", "Hello FirstActivity");
setResult(RESULT_OK, intent);
finish();//销毁当前活动
```

如果用户通过返回键来退出，那么我们可以通过重写onBackPressed，是的在销毁设置返回数据

```java
@Override
public void onBackPressed() {
    Intent intent = new Intent();
    intent.putExtra("data_return", "Hello FirstActivity");
    setResult(RESULT_OK, intent);//第 一个 参数 用于 向上一 个活 动返 回处 理结果，通常是RESULT_OK 或RESULT_CANCELED，第二个是带有数据的Intent
    finish();
}
```

**第三步:设置回调函数来接收数据**



在FirstActivity中重写onActivityResult

```java
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    switch (requestCode) {
        case 1:
            if (resultCode == RESULT_OK) {
                String returnedData = data.getStringExtra("data_return");
                Log.d("FirstActivity", returnedData);
            }
            break;
        default:
    }
}
```

第一个参数 requestCode，即我们在启动活动时传 入的请求码。第二个参数 resultCode，即我们在返回数据时传入的处理结果。第三个参数 data， 即携带着返回数据的 Intent



### 返回数据给上一个活动

```java
    ActivityResultLauncher<Intent> someActivityResultLauncher = registerForActivityResult(
            new ActivityResultContracts.StartActivityForResult(),
            new ActivityResultCallback<ActivityResult>() {
                @Override
                public void onActivityResult(ActivityResult result) {
                    if (result.getResultCode() == Activity.RESULT_OK) {
                        // There are no request code
                        Intent data = result.getData();
                        doSomeOperations();
                    }
                }
            });

    public void openSomeActivityForResult() {
        Intent intent = new Intent(this, SomeActivity.class);
        someActivityResultLauncher.launch(intent);
    }
```





### 活动的生命周期

#### 返回栈

Android 是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动 的集合，这个栈也被称作返回栈（Back Stack）。

在默认情况 下，每当我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶的位置。而每当我们 按下 Back 键或调用 finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入 栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。



![](https://raw.githubusercontent.com/Explorersss/photo/master/20201023113303.png)



#### 活动状态

每个活动在其生命周期中最多可能会有四种状态。 

1. 运行状态
   当一个活动位于返回栈的栈顶时，这时活动就处于运行状态。系统最不愿意回收的 就是处于运行状态的活动，因为这会带来非常差的用户体验。

2. 暂停状态 当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。你可 能会觉得既然活动已经不在栈顶了，还怎么会可见呢？这是因为并不是每一个活动都会 占满整个屏幕的，比如对话框形式的活动只会占用屏幕中间的部分区域，你很快就会在 后面看到这种活动。处于暂停状态的活动仍然是完全存活着的，系统也不愿意去回收这 种活动（因为它还是可见的，回收可见的东西都会在用户体验方面有不好的影响），只 有在内存极低的情况下，系统才会去考虑回收这种活动。 
3.  停止状态 当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统 仍然会为这种活动保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方 需要内存时，处于停止状态的活动有可能会被系统回收。 
4.  销毁状态 当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状 态的活动，从而保证手机的内存充足。



#### 活动的生存期

Activity 类中定义了七个回调方法，覆盖了活动生命周期的每一个环节，下面我来一一 介绍下这七个方法。 

1. onCreate() 
   这个方法你已经看到过很多次了，每个活动中我们都重写了这个方法，它会在活动 第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布 局、绑定事件等。 
2.  onStart() 
   这个方法在活动由不可见变为可见的时候调用。 
3. onResume() 
   这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的 栈顶，并且处于运行状态。 
4. onPause() 
   这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方 法中将一些消耗 CPU 的资源释放掉，以及保存一些关键数据，但这个方法的执行速度 一定要快，不然会影响到新的栈顶活动的使用。
5. onStop()
   这个方法在活动完全不可见的时候调用。它和 onPause()方法的主要区别在于，如 果启动的新活动是一个对话框式的活动，那么 onPause()方法会得到执行，而 onStop() 方法并不会执行。 
6. onDestroy() 
   这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。 
7. onRestart() 
   这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。



以上七个方法中除了 onRestart()方法，其他都是两两相对的，从而又可以将活动分为三 种生存期。 

1. 完整生存期
    活动在 onCreate()方法和 onDestroy()方法之间所经历的，就是完整生存期。一般情 况下，一个活动会在 onCreate()方法中完成各种初始化操作，而在 onDestroy()方法中完 成释放内存的操作。 
2.  可见生存期 
   活动在 onStart()方法和 onStop()方法之间所经历的，就是可见生存期。在可见生存 期内，活动对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两 个方法，合理地管理那些对用户可见的资源。比如在 onStart()方法中对资源进行加载， 而在 onStop()方法中对资源进行释放，从而保证处于停止状态的活动不会占用过多内存。 
3.  前台生存期 
   活动在 onResume()方法和 onPause()方法之间所经历的，就是前台生存期。在前台 生存期内，活动总是处于运行状态的，此时的活动是可以和用户进行相互的，我们平时 看到和接触最多的也这个状态下的活动。

![image-20201023113405095](https://raw.githubusercontent.com/Explorersss/photo/master/20201023113405.png)



### 保存活动状态

当活动退出可见生存期时就有可能被回收，那我们要如何保存他的状态呢

Activity提供了onSaveInstanceState()回调方法，这个方法会保证一定在活动被回收之前调用

onSaveInstanceState()方法会携带一个 Bundle 类型的参数，Bundle 提供了一系列的方法 用于保存数据，比如可以使用 putString()方法保存字符串，使用 putInt()方法保存整型数据， 以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从 Bundle 中取值， 第二个参数是真正要保存的内容

```java
@Override
protected void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    String tempData = "Something you just typed";
    outState.putString("data_key", tempData);
}
```

那么如何取值呢，在onCreate中的参数就是Bundle类型

于是



```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Log.d(TAG, "onCreate");
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    setContentView(R.layout.activity_main);
    if (savedInstanceState != null) {
        String tempData = savedInstanceState.getString("data_key");
        Log.d(TAG, tempData);
    }……
}
```



### 活动的启动模式

启动模式一共有四种，分别是 standard、singleTop、 singleTask 和 singleInstance ， 可 以 在 AndroidManifest.xml 中 通 过 给  标 签 指 定 android:launchMode 属性来选择启动模式。

#### standard

standard 是活动默认的启动模式

每当启动一个新的活动，它就会在返回栈中入栈，并处于栈顶的位置。对于使用 standard 模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建 该活动的一个新的实例。

![image-20201023134352832](https://raw.githubusercontent.com/Explorersss/photo/master/20201023134353.png)



#### singleTop

当活动的启动模式 指定为 singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用 它，不会再创建新的活动实例。

![image-20201023134437902](https://raw.githubusercontent.com/Explorersss/photo/master/20201023134437.png)



#### singleTask

当活动的启动模式指定为 singleTask，每次启动该活动时系统首先 会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这 个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。

![image-20201023134508798](https://raw.githubusercontent.com/Explorersss/photo/master/20201023134508.png)



#### singleInstance

singleInstance 模式的活动会启用一 个新的返回栈来管理这个活动（其实如果 singleTask 模式指定了不同的 taskAffinity，也会启 动一个新的返回栈）。那么这样做有什么意义呢？想象以下场景，假设我们的程序中有一个 活动是允许其他程序调用的，如果我们想实现其他程序和我们的程序可以共享这个活动的实 例，应该如何实现呢？使用前面三种启动模式肯定是做不到的，因为每个应用程序都会有自 己的返回栈，同一个活动在不同的返回栈中入栈时必然是创建了新的实例。而使用 singleInstance 模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活 动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实 例的问题。

![image-20201023134627741](https://raw.githubusercontent.com/Explorersss/photo/master/20201023134627.png)





其中SecondActivity是singleInstance启动模式，而其余的都是standard启动模式

### 活动的开发技巧

#### 知晓当前是哪一个活动

新建一个BaseActivity：

```java
public class BaseActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d("BaseActivity", getClass().getSimpleName());
    }
}
```

让其他活动继承BaseActivity



#### 随时退出程序

新建一个ActivityCollector

```java
public class ActivityCollector {
    public static List<Activity> activities = new ArrayList<Activity>();
    public static void addActivity(Activity activity) {
        activities.add(activity);
    }
    public static void removeActivity(Activity activity) {
        activities.remove(activity);
    }
    public static void finishAll() {
        for (Activity activity : activities) {
            if (!activity.isFinishing()) {
                activity.finish();
            }
        }
    }
}
```



向BaseActivity添加以下代码

```java
public class BaseActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d("BaseActivity", getClass().getSimpleName());
        ActivityCollector.addActivity(this);
    }
    @Override
    protected void onDestroy() {
        super.onDestroy();
        ActivityCollector.removeActivity(this);
    }
}
```



#### 启动活动的最佳写法

封装参数调用



```java
public class SecondActivity extends BaseActivity {
    public static void actionStart(Context context, String data1, String data2) {
        Intent intent = new Intent(context, SecondActivity.class);
        intent.putExtra("param1", data1);
        intent.putExtra("param2", data2);
        context.startActivity(intent);
    }……
}
```





## 编写程序界面

android:layout_width 指定了 控件的宽度，android:layout_height 指定了控件的高度。Android 中所有的控件都具有这 两个属性，可选值有三种 match_parent、fill_parent 和 wrap_content，其中 match_parent 和 fill_parent 的意义相同，现在官方更加推荐使用 match_parent。match_parent 表示让当前控件的大小和父布局的大小一样，也就是由父布局来决定当前控件的大小。wrap_content 表示让 当前控件的大小能够刚好包含住里面的内容，也就是由控件内容决定当前控件的大小。



所有的 Android控件都具有这个属性，可以通过 android:visibility 进行指定，可选值有三种，visible、invisible 和 gone。

相关代码

`progressBar.setVisibility(View.VISIBLE);`



### 常见控件

#### TextView

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:orientation="vertical" >
    <TextView
              android:id="@+id/text_view"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:gravity="center"<!--指定文字对齐方式，可选值有 top、bottom、left、right、center等 ，可以用 “ | ”来同时指定多个值-->
            android:textSize="24sp"
            android:textColor="#00ff00"
            android:text="This is TextView" />
</LinearLayout>
```



#### Button

```xml
<Button
        android:id="@+id/button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Button" />
```

注册监听器

```java
public class MainActivity extends Activity {
    private Button button;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                // 在此处添加逻辑
            }
        });
    }
}
```

如果你不喜欢使用匿名类的方式来注册监听器，也可以使用实现接 口的方式来进行注册



```java
public class MainActivity extends Activity implements OnClickListener {
    private Button button;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        button = (Button) findViewById(R.id.button);
        button.setOnClickListener(this);
    }
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.button:
                // 在此处添加逻辑
                break;
            default:
                break;
        }
    }
}
```



#### EditText



```xml
<EditText
          android:id="@+id/edit_text"
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          android:hint="Type something here"<!-- 提示 -->
		  android:maxLines="2" <!-- 指定了 EditText 的最大行数为两行 -->
		  android:drawableLeft="@drawable/user_name_icon" <!-- 在左侧绘制图片-->
          />
```



```java
editText = (EditText) findViewById(R.id.edit_text);
String inputText = editText.getText().toString();
```



#### ImageView

```xml
<ImageView
           android:id="@+id/image_view"
           android:layout_width="wrap_content"
           android:layout_height="wrap_content"
           android:src="@drawable/ic_launcher"
           />
```



```java
imageView = (ImageView) findViewById(R.id.image_view);
imageView.setImageResource(R.drawable.jelly_bean);
```



#### ProgressBar

![](https://raw.githubusercontent.com/Explorersss/photo/master/20200923215733.png)

```xml
<ProgressBar
             android:id="@+id/progress_bar"
             android:layout_width="match_parent"
             android:layout_height="wrap_content"
             />
```

通过 style 属性 可以将它指定成水平进度条

添加属性：

```xml
style="?android:attr/progressBarStyleHorizontal"
android:max="100"
```

在代码中动态地更改进度条的进度

```java
public void onClick(View v) {
    switch (v.getId()) {
        case R.id.button:
            int progress = progressBar.getProgress();
            progress = progress + 10;
            progressBar.setProgress(progress);
            break;
        default:
            break;
    }
}
```

#### AlertDialog

```java
public class MainActivity extends Activity implements OnClickListener { ……
    @Override
    public void onClick(View v) {
    switch (v.getId()) {
        case R.id.button:
            AlertDialog.Builder dialog = new AlertDialog.Builder
                (MainActivity.this);
            dialog.setTitle("This is Dialog");
            dialog.setMessage("Something important.");
            dialog.setCancelable(false);
            dialog.setPositiveButton("OK", new DialogInterface.
                                     OnClickListener() {
                                         @Override
                                         public void onClick(DialogInterface dialog, int which) {
                                         }
                                     });
            dialog.setNegativeButton("Cancel", new DialogInterface.
                                     OnClickListener() {
                                         @Override
                                         public void onClick(DialogInterface dialog, int which) {
                                         }
                                     });
            dialog.show();
            break;
        default:
            break;
    }
}
                                                                      }
```



#### ProgressDialog

ProgressDialog 会在对话框中显示一个进度条，一般是 用于表示当前操作比较耗时，让用户耐心地等待

```java
public class MainActivity extends Activity implements OnClickListener { ……
    @Override
    public void onClick(View v) {
    switch (v.getId()) {
        case R.id.button:
            ProgressDialog progressDialog = new ProgressDialog
                (MainActivity.this);
            progressDialog.setTitle("This is ProgressDialog");
            progressDialog.setMessage("Loading...");
            progressDialog.setCancelable(true);//如果在 setCancelable()中传入了 false，表示 ProgressDialog 是不能通过 Back 键取消掉的当数据加载完成后必须要调用 ProgressDialog 的dismiss()方法来关闭对话框，否则 ProgressDialog 将会一直存在
            progressDialog.show();
            break;
        default:
            break;
    }
}
                                                                      }
```



### 常用属性



#### android:gravity

让文字居中对齐



#### android:layout_gravity



指定空间在布局中的位置



#### layout_weight



**android:layout_weight** 允许我们使用比例的方式来指定控件的大小，它在手机屏幕的适配性方面可以起到非常重要 的作用

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:orientation="horizontal" >
    <EditText
              android:id="@+id/input_message"
              android:layout_width="0dp"
              android:layout_height="wrap_content"
              android:layout_weight="1"
              android:hint="Type something"
              />
    <Button
            android:id="@+id/send"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Send"
            />
</LinearLayout>
```



将 EditText 和 Button 的宽度都指定成了 0,由于我们使用了 android:layout_weight 属性,此时控件的宽度 就不应该再由 android:layout_width 来决定，这里指定成 0 是一种比较规范的写法

后我们在 EditText 和 Button 里都将 android:layout_weight 属性的值指定为 1，这表示 EditText 和 Button 将在水平方向平分宽度.系统会先把 LinearLayout 下所有控件指定的 layout_weight 值相加，得到一个总值， 然后每个控件所占大小的比例就是用该控件的 layout_weight 值除以刚才算出的总值。



仅指定了 EditText 的 android:layout_weight 属性，并将 Button 的宽度改回 wrap_content。这表示 Button 的宽度仍然按照 wrap_content 来计算，而 EditText 则会占满屏 幕所有的剩余空间。使用这种方式编写的界面，不仅在各种屏幕的适配方面会非常好，而且 看起来也更加舒服，重新运行程序，效果如图 3.20 所示

![](https://raw.githubusercontent.com/Explorersss/photo/master/20200923225153.png)



#### layout_margin

android:layout_margin 这个属 性，它可以指定控件在上下左右方向上偏移的距离，当然也可以使用 android:layout_marginLeft 或 android:layout_marginTop 等属性来单独指定控件在某个方向上偏移的距离。



### 常用布局



#### LinearLayout

LinearLayout 称作线性布局，这 个布局会将它所包含的控件在线性方向上依次排列

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:orientation="vertical" >
</LinearLayout>
```

通过 android:orientation来指定是水平还是垂直布局

如果 LinearLayout 的排列方向是 horizontal，内部的控件就绝对不能将 宽度指定为 match_parent，因为这样的话单独一个控件就会将整个水平方向占满。如果 LinearLayout 的排列方向是 vertical，内部的控件就不能将高度指定为 match_parent。

**android:layout_gravity** 属性 用于指定控件在布局中的对齐 方 式



#### RelativeLayout

RelativeLayout 称作相对布局，RelativeLayout 显得更加随意一些，它可以通过相对定位的方式让控件出现在布局 的任何位置。



```xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:layout_width="match_parent"
                android:layout_height="match_parent" >
    <Button
            android:id="@+id/button1"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentLeft="true"
            android:layout_alignParentTop="true"
            android:text="Button 1" />
    <Button
            android:id="@+id/button2"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentRight="true"
            android:layout_alignParentTop="true"
            android:text="Button 2" />
    <Button
            android:id="@+id/button3"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_centerInParent="true"
            android:text="Button 3" />
    <Button
            android:id="@+id/button4"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentBottom="true"
            android:layout_alignParentLeft="true"
            android:text="Button 4" />
    <Button
            android:id="@+id/button5"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentBottom="true"
            android:layout_alignParentRight="true"
            android:text="Button 5" />
</RelativeLayout>
```

![](https://raw.githubusercontent.com/Explorersss/photo/master/20200923225334.png)





```xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:layout_width="match_parent"
                android:layout_height="match_parent" >
    <Button
            android:id="@+id/button3"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_centerInParent="true"
            android:text="Button 3" />
    <Button
            android:id="@+id/button1"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_above="@id/button3"
            android:layout_toLeftOf="@id/button3"
            android:text="Button 1" />
    <Button
            android:id="@+id/button2"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_above="@id/button3"
            android:layout_toRightOf="@id/button3"
            android:text="Button 2" />
    <Button
            android:id="@+id/button4"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_below="@id/button3"
            android:layout_toLeftOf="@id/button3"
            android:text="Button 4" />
    <Button
            android:id="@+id/button5"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_below="@id/button3"
            android:layout_toRightOf="@id/button3"
            android:text="Button 5" />
</RelativeLayout>
```

android:layout_above 属性可以让 一个控件位于另一个控件的上方，需要为这个属性指定相对控件 id 的引用，这里我们填入 了 @id/button3， 表 示 让 该 控 件 位 于 Button 3 的 上 方 。 其 他 的 属 性 也 都 是 相 似 的 ， android:layout_below 表示让一个控件位于另一个控件的下方，android:layout_toLeftOf 表示让 一个控件位于另一个控件的左侧，android:layout_toRightOf 表示让一个控件位于另一个控件 的右侧。**注意，当一个控件去引用另一个控件的 id 时，该控件一定要定义在引用控件的后 面，不然会出现找不到 id 的情况。**

![](https://raw.githubusercontent.com/Explorersss/photo/master/20200923225431.png)



RelativeLayout 中还有另外一组相对于控件进行定位的属性，android:layout_alignLeft 表 示让一个控件的左边缘和另一个控件的左边缘对齐，android:layout_alignRight 表示让一个控件的右边缘和另一个控件的右边缘对齐，还有 android:layout_alignTop 和 android:layout_ alignBottom

#### FrameLayout

这种 布局没有任何的定位方式，所有的控件都会摆放在布局的左上角

```xml
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
             android:layout_width="match_parent"
             android:layout_height="match_parent"
             >
    <Button
            android:id="@+id/button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Button"
            />
    <ImageView
               android:id="@+id/image_view"
               android:layout_width="wrap_content"
               android:layout_height="wrap_content"
               android:src="@drawable/ic_launcher"
               />
</FrameLayout>
```

![](https://raw.githubusercontent.com/Explorersss/photo/master/20200923225549.png)

由于图片是在按钮之后添加的，因此图 片压在了按钮的上面。



#### TableLayout

TableLayout 允许我们使用表格的方式来排列控件

在设计表格时我们 尽量应该让每一行都拥有相同的列数，这样的表格也是最简单的。不过有时候事情并非总会 顺从我们的心意，当表格的某行一定要有不相等的列数时，就需要通过合并单元格的方式来 应对。

```xml
<TableLayout xmlns:android="http://schemas.android.com/apk/res/android"
             android:layout_width="match_parent"
             android:layout_height="match_parent" 
             android:stretchColumns="1"
             >
    <TableRow>
        <TextView
                  android:layout_height="wrap_content"
                  android:text="Account:" />
        <EditText
                  android:id="@+id/account"
                  android:layout_height="wrap_content"
                  android:hint="Input your account" />
    </TableRow>
    <TableRow>
        <TextView
                  android:layout_height="wrap_content"
                  android:text="Password:" />
        <EditText
                  android:id="@+id/password"
                  android:layout_height="wrap_content"
                  android:inputType="textPassword" />
    </TableRow>
    <TableRow>
        <Button
                android:id="@+id/login"
                android:layout_height="wrap_content"
                android:layout_span="2"
                android:text="Login" />
    </TableRow>
</TableLayout>
```

在 TableLayout 中每加入一个 TableRow 就表示在表格中添加了一行，然后在 TableRow 中每加入一个控件，就表示在该行中加入了一列，TableRow 中的控件是不能指定宽度的

第三行只有一列，这样的表格就会很难看，而且 结 构 也 非 常 不 合 理 。 这 时 就 需 要 通 过 对 单 元 格 进 行 合 并 来 解 决 这 个 问 题 ， 使 用 android:layout_span="2"让登录按钮占据两列的空间，就可以保证表格结构的合理性了。

当前的登录界面并没有充分利用屏幕的宽度，右侧还空出了一块 区 域 ， 这 也 难 怪 ， 因 为 在 TableRow 中 我 们 无 法 指 定 控 件 的 宽 度 。 这 时 使 用 android:stretchColumns 属性就可以很好地解决这个问题，它允许将 TableLayout 中的某一列 进行拉伸，以达到自动适应屏幕宽度的作用。

指定成 1 就是拉伸第二列，指定成 0 就是拉伸第一列



### 自定义控件



#### 控件和布局的继承结构

![image-20201021100106495](https://raw.githubusercontent.com/Explorersss/photo/master/20201021100106.png)





可以看到，我们所用的所有控件都是直接或间接继承自 View 的，所用的所有布局都是 直接或间接继承自 ViewGroup 的。View 是 Android 中一种最基本的 UI 组件，它可以在屏幕 上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是 在 View 的基础之上又添加了各自特有的功能。而 ViewGroup 则是一种特殊的 View，它可以 包含很多的子 View 和子 ViewGroup，是一个用于放置控件和布局的容器。



#### 包含布局

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
android:layout_width="match_parent"
android:layout_height="match_parent" >
    <include layout="@layout/title" />
</LinearLayout>
```



#### 创建自定义控件

创建自定义控件的好处就是我们可以在里面添加一些常用的代码，比如事件注册等等

```java
public class TitleLayout extends LinearLayout {
    public TitleLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        LayoutInflater.from(context).inflate(R.layout.title, this);
        Button titleBack = (Button) findViewById(R.id.title_back);
        Button titleEdit = (Button) findViewById(R.id.title_edit);
        titleBack.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                ((Activity) getContext()).finish();
            }
        });
        titleEdit.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                Toast.makeText(getContext(), "You clicked Edit button",
                               Toast.LENGTH_SHORT).show();
            }
        });
    }
}
```

> 首先我们重写了 LinearLayout 中的带有两个参数的构造函数，在布局中引入 TitleLayout 控件就会调用这个构造函数。然后在构造函数中需要对标题栏布局进行动态加载，这就要借 助 LayoutInflater 来实现了。通过 LayoutInflater 的 from()方法可以构建出一个 LayoutInflater 对象，然后调用 inflate()方法就可以动态加载一个布局文件，inflate()方法接收两个参数，第 一个参数是要加载的布局文件的 id，这里我们传入 R.layout.title，第二个参数是给加载好的 布局再添加一个父布局，这里我们想要指定为 TitleLayout，于是直接传入 this。

在布局文件中导入

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent" >
    <com.example.uicustomviews.TitleLayout
                                           android:layout_width="match_parent"
                                           android:layout_height="wrap_content"
                                           ></com.example.uicustomviews.TitleLayout>
</LinearLayout>
```

与自带控件不同的是，这里需要指定完整的类名



##### 为自定义控件设置属性

https://developer.android.com/training/custom-views/create-view#customattr



第一步，向res/values/attrs.xml添加declare-styleable属性：

```xml
<resources>
    <declare-styleable name="TitleLayout">
        <attr name="title_text" format="string"></attr>
    </declare-styleable>
</resources>
```



第二步向引用他的layout添加命名空间

```xml
<LinearLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        xmlns:custom="http://schemas.android.com/apk/res-auto"
        android:orientation="vertical"
        android:background="@drawable/login_bg"
        android:weightSum="20"
        tools:context=".LoginPage"

        >
    <top.ccreater.practicelist.TitleLayout
            android:layout_height="wrap_content"
            android:layout_width="match_parent"
            custom:title_text="登入"
            >

    </top.ccreater.practicelist.TitleLayout>
<LinearLayout/>
```



第三步引用自定义属性

```java
public class TitleLayout extends LinearLayout {
    public TitleLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        TypedArray attrList = context.getTheme().obtainStyledAttributes(
                attrs,
                R.styleable.TitleLayout,
                0, 0);

        LayoutInflater.from(context).inflate(R.layout.title, this);
        try {
            String text = attrList.getString(R.styleable.TitleLayout_title_text);
            TextView title= (TextView)findViewById(R.id.title_template);
            title.setText(text);
        } finally {
            attrList.recycle();
        }

    }
}
```







### ListView

最常用和最难用的控件——ListView



#### 简单使用



```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent" >
    <ListView
              android:id="@+id/list_view"
              android:layout_width="match_parent"
              android:layout_height="match_parent" >
    </ListView>
</LinearLayout>
```

MainActivity 中的代码:

```java
public class MainActivity extends Activity {
    private String[] data = { "Apple", "Banana", "Orange", "Watermelon",
                             "Pear", "Grape", "Pineapple", "Strawberry", "Cherry", "Mango" };
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ArrayAdapter<String> adapter = new ArrayAdapter<String>(
            MainActivity.this, android.R.layout.simple_list_item_1, data);
        ListView listView = (ListView) findViewById(R.id.list_view);
        listView.setAdapter(adapter);
    }
}
```

数组中的数据是无法直接传递给 ListView 的，我们还需要借助适配器(Adapter)来完成。

其中ArrayAdapter就是一个常用的适配器。只要通 过泛型来指定要适配的数据类型，然后在构造函数中把要适配的数据传入即可。

将 ArrayAdapter 的泛型指定为 String，然后在 ArrayAdapter 的构造函数中 依次传入当前上下文、ListView 子项布局的 id，以及要适配的数据。

意我们使用了 android.R.layout.simple_list_item_1 作为 ListView 子项布局的 id，这是一个 Android 内置的布 局文件，里面只有一个 TextView，可用于简单地显示一段文本。

最后，还需要调用 ListView 的 setAdapter()方法，将构建好的适配器对象传递进去，这 样 ListView 和数据之间的关联就建立完成了。

![image-20201023142356518](https://raw.githubusercontent.com/Explorersss/photo/master/20201023142356.png)



#### 定制ListView的界面

目标：一个水果名显示一个水果图片

新建类Fruit

```java
public class Fruit {
    private String name;
    private int imageId;
    public Fruit(String name, int imageId) {
        this.name = name;
        this.imageId = imageId;
    }
    public String getName() {
        return name;
    }
    public int getImageId() {
        return imageId;
    }
}
```

为 ListView 的子项指定一个我们自定义的布局，在 layout 目录下新建 fruit_item.xml，代码如下所示：



```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent" >
    <ImageView
               android:id="@+id/fruit_image"
               android:layout_width="wrap_content"
               android:layout_height="wrap_content" />
    <TextView
              android:id="@+id/fruit_name"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_gravity="center"
              android:layout_marginLeft="10dip" />
</LinearLayout>
```

在这个布局中，我们定义了一个 ImageView 用于显示水果的图片，又定义了一个 TextView 用于显示水果的名称。 接下来需要创建一个自定义的适配器，这个适配器继承自 ArrayAdapter，并将泛型指定 为 Fruit 类。新建类 FruitAdapter，代码如下所示



```java
public class FruitAdapter extends ArrayAdapter<Fruit> {
    private int resourceId;
    public FruitAdapter(Context context, int textViewResourceId,
                        List<Fruit> objects) {
        super(context, textViewResourceId, objects);
        resourceId = textViewResourceId;
    }
    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        Fruit fruit = getItem(position); // 获取当前项的Fruit实例
        View view = LayoutInflater.from(getContext()).inflate(resourceId, null);
        ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
        TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);
        fruitImage.setImageResource(fruit.getImageId());
        fruitName.setText(fruit.getName());
        return view;
    }
}
```



FruitAdapter 重写了父类的一组构造函数，用于将上下文、ListView 子项布局的 id 和数 据都传递进来。另外又重写了 getView()方法，这个方法在每个子项被滚动到屏幕内的时候 会被调用。在 getView 方法中，首先通过 getItem()方法得到当前项的 Fruit 实例，然后使用 LayoutInflater 来为这个子项加载我们传入的布局，接着调用 View 的 findViewById()方法分别 获取到 ImageView 和 TextView 的实例，并分别调用它们的 setImageResource()和 setText()方 法来设置显示的图片和文字，最后将布局返回，这样我们自定义的适配器就完成了

下面修改 MainActivity 中的代码，如下所示：

```java
public class MainActivity extends Activity {
    private List<Fruit> fruitList = new ArrayList<Fruit>();
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits(); // 初始化水果数据
        FruitAdapter adapter = new FruitAdapter(MainActivity.this,
                                                R.layout.fruit_item, fruitList);
        ListView listView = (ListView) findViewById(R.id.list_view);
        listView.setAdapter(adapter);
    }
    private void initFruits() {
        Fruit apple = new Fruit("Apple", R.drawable.apple_pic);
        fruitList.add(apple);
        ...
    }
}
```

可以看到，这里添加了一个 initFruits()方法，用于初始化所有的水果数据。在 Fruit 类的 构造函数中将水果的名字和对应的图片 id 传入，然后把创建好的对象添加到水果列表中。 接着我们在 onCreate()方法中创建了 FruitAdapter 对象，并将 FruitAdapter 作为适配器传递给 了 ListView。这样定制 ListView 界面的任务就完成了。



![image-20201023143754944](https://raw.githubusercontent.com/Explorersss/photo/master/20201023143755.png)





#### 提升ListView的运行效率

在先前的代码中，我们每次添加一个项，都会重新引入布局，导致了性能的下降，通过以下代码来重新利用导入的布局

```java
public class FruitAdapter extends ArrayAdapter<Fruit> { ……
    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
    Fruit fruit = getItem(position);
    View view;
    if (convertView == null) {
        view = LayoutInflater.from(getContext()).inflate(resourceId, null);
    } else {
        view = convertView;
    }
    ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
    TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);
    fruitImage.setImageResource(fruit.getImageId());
    fruitName.setText(fruit.getName());
    return view;
}
                                                      }
```

还有一点，每次在 getView()方法中还是会调用 View的 findViewById()方法来获取一次控件的实例。

通过以下代码来优化

```java
public class FruitAdapter extends ArrayAdapter<Fruit> { ……
    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
    Fruit fruit = getItem(position);
    View view;
    ViewHolder viewHolder;
    if (convertView == null) {
        view = LayoutInflater.from(getContext()).inflate(resourceId, null);
        viewHolder = new ViewHolder();
        viewHolder.fruitImage = (ImageView) view.findViewById
            (R.id.fruit_image);
        viewHolder.fruitName = (TextView) view.findViewById
            (R.id.fruit_name);
        view.setTag(viewHolder); // 将ViewHolder存储在View中
    } else {
        view = convertView;
        viewHolder = (ViewHolder) view.getTag(); // 重新获取ViewHolder
    }
    viewHolder.fruitImage.setImageResource(fruit.getImageId());
    viewHolder.fruitName.setText(fruit.getName());
    return view;
}
                                                       class ViewHolder {
                                                           ImageView fruitImage;
                                                           TextView fruitName;
                                                       }
```





#### ListView 的点击事件



```java
public class MainActivity extends Activity {
    private List<Fruit> fruitList = new ArrayList<Fruit>();
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        ListView listView = (ListView) findViewById(R.id.list_view);
        listView.setAdapter(adapter);
        listView.setOnItemClickListener(new OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view,
                                    int position, long id) {
                Fruit fruit = fruitList.get(position);
                ...
            }
        });
    }……
}
```



### 单位和尺寸

为了在不同的分辨率下的显示，推荐使用dp(控件使用),sp（字体使用）

px = dp * (dpi / 160)



### RecyclerView

RecyclerView 微件是 ListView 的更高级、灵活版本。

添加RecyclerView 到布局

```xml
    <?xml version="1.0" encoding="utf-8"?>
    <!-- A RecyclerView with some commonly used attributes -->
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/my_recycler_view"
        android:scrollbars="vertical"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
    
```

MainActivity代码：

```java
    public class MyActivity extends Activity {
        private RecyclerView recyclerView;
        private RecyclerView.Adapter mAdapter;
        private RecyclerView.LayoutManager layoutManager;

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.my_activity);
            recyclerView = (RecyclerView) findViewById(R.id.my_recycler_view);

            // use this setting to improve performance if you know that changes
            // in content do not change the layout size of the RecyclerView
            recyclerView.setHasFixedSize(true);

            // use a linear layout manager
            layoutManager = new LinearLayoutManager(this);
            recyclerView.setLayoutManager(layoutManager);

            // specify an adapter (see also next example)
            mAdapter = new MyAdapter(myDataset);
            recyclerView.setAdapter(mAdapter);
        }
        // ...
    }
    
```



创建适配器

```java
    public class MyAdapter extends RecyclerView.Adapter<MyAdapter.MyViewHolder> {
        private String[] mDataset;

        // Provide a reference to the views for each data item
        // Complex data items may need more than one view per item, and
        // you provide access to all the views for a data item in a view holder
        public static class MyViewHolder extends RecyclerView.ViewHolder {
            // each data item is just a string in this case
            public TextView textView;
            public MyViewHolder(TextView v) {
                super(v);
                textView = v;
            }
        }

        // Provide a suitable constructor (depends on the kind of dataset)
        public MyAdapter(String[] myDataset) {
            mDataset = myDataset;
        }

        // Create new views (invoked by the layout manager)
        @Override
        public MyAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent,
                                                       int viewType) {
            // create a new view
            TextView v = (TextView) LayoutInflater.from(parent.getContext())
                    .inflate(R.layout.my_text_view, parent, false);
            ...
            MyViewHolder vh = new MyViewHolder(v);
            return vh;
        }

        // Replace the contents of a view (invoked by the layout manager)
        @Override
        public void onBindViewHolder(MyViewHolder holder, int position) {
            // - get element from your dataset at this position
            // - replace the contents of the view with that element
            holder.textView.setText(mDataset[position]);

        }

        // Return the size of your dataset (invoked by the layout manager)
        @Override
        public int getItemCount() {
            return mDataset.length;
        }
    }
    
```



## 数据存储

Android 系统中主要提供了三种方式用于简单地实现数据持久化功能， 即文件存储、SharedPreference 存储以及数据库存储

### 文件存储



#### 写入文件



```java
public void save() {
    String data = "Data to save";
    FileOutputStream out = null;
    BufferedWriter writer = null;
    try {
        out = openFileOutput("data", Context.MODE_PRIVATE);
        writer = new BufferedWriter(new OutputStreamWriter(out));
        writer.write(data);
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        try {
            if (writer != null) {
                writer.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

Context提供的openFileOutput有两种写入模式MODE_PRIVATE 和 MODE_APPEND。

所有的文件都是默认存储到/data/data//files/ 目 录 下



#### 读取文件

```java
public String load() {
    FileInputStream in = null;
    BufferedReader reader = null;
    StringBuilder content = new StringBuilder();
    try {
        in = openFileInput("data");
        reader = new BufferedReader(new InputStreamReader(in));
        String line = "";
        while ((line = reader.readLine()) != null) {
            content.append(line);
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (reader != null) {
            try {
                reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    return content.toString();
}
```

### SharedPreferences 存储

SharedPreferences 是使用键值对的方式来存储数据的



#### 写入数据

要想使用SharedPreferences来存储数据，首先需要获取到SharedPreferences对象。Android 中主要提供了三种方法用于得到 SharedPreferences 对象。

1. Context 类中的 getSharedPreferences()方法
   此方法接收两个参数，第一个参数用于指定 SharedPreferences 文件的名称，如果指 定的文件不存在则会创建一个，SharedPreferences 文件都是存放在/data/data//shared_prefs/目录下的。第二个参数用于指定操作模式，主要有两种模式可以选 择，MODE_PRIVATE 和 MODE_MULTI_PROCESS。MODE_MULTI_PROCESS 则一般是用于会有多个进程中 对同一个 SharedPreferences 文件进行读写的情况
2. Activity 类中的 getPreferences()方法
   这个方法和 Context 中的 getSharedPreferences()方法很相似，不过它只接收一个操 作模式参数，因为使用这个方法时会自动将当前活动的类名作为 SharedPreferences 的文 件名
3. PreferenceManager 类中的 getDefaultSharedPreferences()方法
   这是一个静态方法，它接收一个 Context 参数，并自动使用当前应用程序的包名作 为前缀来命名 SharedPreferences 文件

得到了 SharedPreferences 对象之后，就可以开始向 SharedPreferences 文件中存储数据了， 

主要可以分为三步实现。 

1. 调用 SharedPreferences 对象的 edit()方法来获取一个 SharedPreferences.Editor 对象。 
2.  向 SharedPreferences.Editor 对象中添加数据，比如添加一个布尔型数据就使用 putBoolean 方法，添加一个字符串则使用 putString()方法，以此类推。 
3. 调用 commit()方法将添加的数据提交，从而完成数据存储操作。

#### 读取数据



```java
public class MainActivity extends Activity {
    private Button saveData;
    private Button restoreData;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        saveData = (Button) findViewById(R.id.save_data);
        restoreData = (Button) findViewById(R.id.restore_data); ……
            restoreData.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    SharedPreferences pref = getSharedPreferences("data",
                                                                  MODE_PRIVATE);
                    String name = pref.getString("name", "");
                    int age = pref.getInt("age", 0);
                    boolean married = pref.getBoolean("married", false);
                    Log.d("MainActivity", "name is " + name);
                    Log.d("MainActivity", "age is " + age);
                    Log.d("MainActivity", "married is " + married);
                }
            });
    }
}
```



### SQLite 数据库存储

利用SQLiteOpenHelper来管理数据库



#### SQLite的数据类型

integer 表示整型

real 表示浮点型

text 表示文本类型

blob 表示二进制类型

使用了 primary key 将 id 列设为主键，并用 autoincrement 关键字表示 id 列是自增长的



#### SQLite命令行查询操作

`adb shell`进入shell

`sqlite3 dbname`打开数据库

`.table`查看表

`.scheme`查看建表语句

`.exit`退出





#### 创建数据库

SQLiteOpenHelper 中有两个抽象方法，分别是 onCreate()和 onUpgrade()，我们必须在自己的帮助类里面重写这两个方法，然后分别在这两 个方法中去实现创建、升级数据库的逻辑

SQLiteOpenHelper 中 还 有 两 个 非 常 重 要 的 实 例 方 法 ， getReadableDatabase() 和 getWritableDatabase()

```java
public class MyDatabaseHelper extends SQLiteOpenHelper {
    public static final String CREATE_BOOK = "sql语句"
    private Context mContext;
    public MyDatabaseHelper(Context context, String name, CursorFactory
                            factory, int version) {
        
        //name是数据库名，factory让我们创建自定义cursor,version代表数据库版本
        super(context, name, factory, version);
        mContext = context;
    }
    @Override
    public void onCreate(SQLiteDatabase db) {
        //当数据库不存在就会被调用
        db.execSQL(CREATE_BOOK);
    }
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        //版本改变便会被调用
    }
}
```

数据库文件会存放在/data/data//databases/目录



#### 添加数据

```java
SQLiteDatabase db = dbHelper.getWritableDatabase();
ContentValues values = new ContentValues();
values.put("name", "The Da Vinci Code");
values.put("author", "Dan Brown");
values.put("pages", 454);
values.put("price", 16.96);
db.insert("Book", null, values);
//第一个参数是表名,第二个参数用于在未指定添加数据的情况下给某些可为空的列自动赋值 NULL,第三个参数是一个 ContentValues 对象
```





#### 更新数据

```java
ContentValues values = new ContentValues();
values.put("price", 10.99);
db.update("Book", values, "name = ?", new String[] { "The DaVinci Code" });
//第二个参数是更新后的数据，第三个参数是一个预处理sql语句字符串，第四个参数是String数组
```



#### 删除数据

```java
SQLiteDatabase db = dbHelper.getWritableDatabase();
db.delete("Book", "pages > ?", new String[] { "500" });
```



#### 查询数据

query函数的七个参数



![image-20201023204252581](https://raw.githubusercontent.com/Explorersss/photo/master/20201023204252.png)



```java
Cursor cursor = db.query("Book", null, null, null, null, null, null);
if (cursor.moveToFirst()) {
    do {
        // 遍历Cursor对象，取出数据并打印
        String name = cursor.getString(cursor.
                                       getColumnIndex("name"));
        String author = cursor.getString(cursor.
                                         getColumnIndex("author"));
        int pages = cursor.getInt(cursor.getColumnIndex
                                  ("pages"));
        double price = cursor.getDouble(cursor.
                                        getColumnIndex("price"));
    } while (cursor.moveToNext());
}

```





#### 使用sql语句

```java
db.execSQL("insert into Book (name, author, pages, price) values(?, ?, ?, ?)",
new String[] { "The Da Vinci Code", "Dan Brown", "454", "16.96" });
```



#### 事务

```java
public void onClick(View v) {
    SQLiteDatabase db = dbHelper.getWritableDatabase();
    db.beginTransaction(); // 开启事务
    try {
        db.delete("Book", null, null);
        if (true) {
            // 在这里手动抛出一个异常，让事务失败
            throw new NullPointerException();
        }
        ContentValues values = new ContentValues();
        values.put("name", "Game of Thrones");
        values.put("author", "George Martin");
        values.put("pages", 720);
        values.put("price", 20.85);
        db.insert("Book", null, values);
        db.setTransactionSuccessful(); // 事务已经执行成功
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        db.endTransaction(); // 结束事务
    }
}
```



## 碎片



### 创建碎片

#### 创建碎片的布局文件

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
             xmlns:tools="http://schemas.android.com/tools"
             android:layout_width="match_parent"
             android:layout_height="match_parent"
             tools:context=".BlankFragment">

    <!-- TODO: Update blank fragment layout -->
    <TextView
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:text="@string/hello_blank_fragment"/>

</FrameLayout>
```

和创建活动的布局文件相同



#### 创建碎片类

```java

public class BlankFragment extends Fragment {
 	private static final String ARG_PARAM1 = "param1";
    private static final String ARG_PARAM2 = "param2";

    public BlankFragment() {
        // Required empty public constructor
    }

    public static BlankFragment newInstance(String param1, String param2) {
        BlankFragment fragment = new BlankFragment();
        Bundle args = new Bundle();
        args.putString(ARG_PARAM1, param1);
        args.putString(ARG_PARAM2, param2);
        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        if (getArguments() != null) {
            mParam1 = getArguments().getString(ARG_PARAM1);
            mParam2 = getArguments().getString(ARG_PARAM2);
        }
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_blank, container, false);
    }
}
```



在onCreateView中引入碎片的布局文件

### 添加到活动中



```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        tools:context=".MainActivity">
    <fragment
            android:id="@+id/up_fragment"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:name="top.ccreater.learn.TestFragment"
            android:layout_weight="1">

    </fragment>

</LinearLayout>
```

android:name指定碎片类

android:layout_weight决定占屏幕的多少



### 动态替换碎片

```java
AnotherRightFragment fragment = new AnotherRightFragment();//要添加的碎片
FragmentManager fragmentManager = getFragmentManager();
FragmentTransaction transaction = fragmentManager.
beginTransaction();
transaction.replace(R.id.right_layout, fragment);//把R.id.right_layouyt替换成fragment
transaction.commit();
```



### 在碎片中模拟返回栈

替换了碎片后，直接按返回发现并不会回到上一个碎片，这时候我们就需要模拟返回栈

使用addToBackStack()

```java
AnotherRightFragment fragment = new AnotherRightFragment();
FragmentManager fragmentManager = getFragmentManager();
FragmentTransaction transaction = fragmentManager.
beginTransaction();
transaction.replace(R.id.right_layout, fragment);
transaction.addToBackStack(null);
transaction.commit();
```



### 碎片和活动之间进行通信

FragmentManager 提供了一个类似于findViewById()的方法，专门用于从布局文件中获取碎片的实例，代码如下所示：
`RightFragment rightFragment = (RightFragment) getFragmentManager()
.findFragmentById(R.id.right_fragment);`

在api level 28 时被废弃，改而用`getActivity().getSupportFragmentManager();`

调用FragmentManager 的findFragmentById()方法，可以在活动中得到相应碎片的实例，
然后就能轻松地调用碎片里的方法了。

**在每个碎片中都可以通过调用getActivity()方法来得到和当前碎片相关联的活动实例**



### 碎片的生命周期

1. 运行状态
当一个碎片是可见的，并且它所关联的活动正处于运行状态时，该碎片也处于运行
状态。

2. 暂停状态
当一个活动进入暂停状态时（由于另一个未占满屏幕的活动被添加到了栈顶），与
它相关联的可见碎片就会进入到暂停状态。
3. 停止状态
当一个活动进入停止状态时，与它相关联的碎片就会进入到停止状态。或者通过调
用FragmentTransaction 的remove()、replace()方法将碎片从活动中移除，但有在事务提
交之前调用addToBackStack()方法，这时的碎片也会进入到停止状态。总的来说，进入
停止状态的碎片对用户来说是完全不可见的，有可能会被系统回收。
4. 销毁状态
碎片总是依附于活动而存在的，因此当活动被销毁时，与它相关联的碎片就会进入
到销毁状态。或者通过调用FragmentTransaction 的remove()、replace()方法将碎片从活
动中移除，但在事务提交之前并没有调用addToBackStack()方法，这时的碎片也会进入
到销毁状态

碎片还提供了一些附加的回调方法，那我们就重点来看下这几个回调。
1. onAttach()
当碎片和活动建立关联的时候调用。
2. onCreateView()
为碎片创建视图（加载布局）时调用。
3. onActivityCreated()
确保与碎片相关联的活动一定已经创建完毕的时候调用。
4. onDestroyView()
当与碎片关联的视图被移除的时候调用。
5. onDetach()
当碎片和活动解除关联的时候调用。



![image-20201027200112393](https://raw.githubusercontent.com/Explorersss/photo/master/20201027200112.png)



### 在不同大小的设备上加载不同布局

#### 使用限定符

```
res
----layout
--------activity_main.xml
----layout-large
--------activity_main.xml

```

当设备被安卓认为大的时候就会使用layout-large下的activity_main.xml



#### 使用最小宽度限定符

```
res
----layout
--------activity_main.xml
----layout-sw600dp
--------activity_main.xml

```



当程序运行在屏幕宽度大于600dp 的设备上时，会加载layout-sw600dp/
activity_main 布局，当程序运行在屏幕宽度小于600dp 的设备上时，则仍然加载默认的
layout/activity_main 布局。





## 导航

https://developer.android.com/guide/navigation

导航是指支持用户导航、进入和退出应用中不同内容片段的交互。



导航组件由以下三个关键部分组成：

- 导航图：在一个集中位置包含所有导航相关信息的 XML 资源。这包括应用内所有单个内容区域（称为*目标*）以及用户可以通过应用获取的可能路径。
- `NavHost`：显示导航图中目标的空白容器。导航组件包含一个默认 `NavHost` 实现 ([`NavHostFragment`](https://developer.android.com/reference/androidx/navigation/fragment/NavHostFragment))，可显示 Fragment 目标。
- `NavController`：在 `NavHost` 中管理应用导航的对象。当用户在整个应用中移动时，`NavController` 会安排 `NavHost` 中目标内容的交换。



### 添加依赖

```
dependencies {
  def nav_version = "2.3.0"

  // Java language implementation
  implementation "androidx.navigation:navigation-fragment:$nav_version"
  implementation "androidx.navigation:navigation-ui:$nav_version"

  // Kotlin
  implementation "androidx.navigation:navigation-fragment-ktx:$nav_version"
  implementation "androidx.navigation:navigation-ui-ktx:$nav_version"

  // Feature module Support
  implementation "androidx.navigation:navigation-dynamic-features-fragment:$nav_version"

  // Testing Navigation
  androidTestImplementation "androidx.navigation:navigation-testing:$nav_version"
}
```



### Navigation Editor



```xml
<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android"
            xmlns:app="http://schemas.android.com/apk/res-auto"
            android:id="@+id/nav_graph">

</navigation>
```

`<navigation>` 元素是导航图的根元素。当您向图表添加目的地和连接操作时，可以看到相应的 `<destination>` 和 `<action>` 元素在此处显示为子元素。如果您有[嵌套图表](https://developer.android.com/guide/navigation/navigation-nested-graphs)，它们将显示为子 `<navigation>` 元素。



### 向Activity添加NavHost



导航宿主是 Navigation 组件的核心部分之一。导航宿主是一个空容器，用户在您的应用中导航时，目的地会在该容器中交换进出。

导航宿主必须派生于 [`NavHost`](https://developer.android.com/reference/androidx/navigation/NavHost)。Navigation 组件的默认 `NavHost` 实现 ([`NavHostFragment`](https://developer.android.com/reference/androidx/navigation/fragment/NavHostFragment)) 负责处理 Fragment 目的地的交换。

```xml
<androidx.fragment.app.FragmentContainerView
        android:id="@+id/nav_host_fragment"
        android:name="androidx.navigation.fragment.NavHostFragment"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"

        app:defaultNavHost="true"
        app:navGraph="@navigation/nav_graph" />

```

- `android:name` 属性包含 `NavHost` 实现的类名称。
- `app:navGraph` 属性将 `NavHostFragment` 与导航图相关联。导航图会在此 `NavHostFragment` 中指定用户可以导航到的所有目的地。
- `app:defaultNavHost="true"` 属性确保您的 `NavHostFragment` 会拦截系统返回按钮。请注意，只能有一个默认 `NavHost`。如果同一布局（例如，双窗格布局）中有多个主机，请务必仅指定一个默认 `NavHost`。



### 向导航图添加目的地

点击Navigation editor中的+号即可



目的地参数解释

点击一个目的地以将其选中，并注意 **Attributes** 面板中显示的以下属性：

- **Type** 字段指示在您的源代码中，该目的地是作为 Fragment、Activity 还是其他自定义类实现的。
- **Label** 字段包含该目的地的 XML 布局文件的名称。
- **ID** 字段包含该目的地的 ID，它用于在代码中引用该目的地。
- **Class** 下拉列表显示与该目的地相关联的类的名称。您可以点击此下拉列表，将相关联的类更改为其他目的地类型。

点击 **Text** 标签页可查看导航图的 XML 视图。XML 中同样包含该目的地的 `id`、`name`、`label` 和 `layout` 属性，如下所示：

```xml
<?xml version="1.0" encoding="utf-8"?><navigation xmlns:app="http://schemas.android.com/apk/res-auto"  xmlns:tools="http://schemas.android.com/tools"  xmlns:android="http://schemas.android.com/apk/res/android"  app:startDestination="@id/blankFragment">  <fragment
    android:id="@+id/blankFragment"
    android:name="com.example.cashdog.cashdog.BlankFragment"
    android:label="Blank"
    tools:layout="@layout/fragment_blank" /></navigation>
```

### 设置起始目的地



[起始目的地](https://developer.android.com/guide/navigation/navigation-principles)是用户打开您的应用时看到的第一个屏幕，也是用户退出您的应用时看到的最后一个屏幕。Navigation Editor 使用房子图标 ![img](https://developer.android.com/studio/images/buttons/navigation-house.png) 表示起始目的地。

所有目的地就绪后，您便可以选择起始目的地，具体操作步骤如下：

1. 在 **Design** 标签页中，点击相应目的地，使其突出显示。
2. 点击 **Assign start destination** 按钮 ![img](https://developer.android.com/images/topic/libraries/architecture/navigation-start-destination-icon.png)。或者，您可以右键点击该目的地，然后点击 **Set as Start Destination**。

### 连接目的地

点击目的地旁边的圆圈然后就可以连接了

实例xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:android="http://schemas.android.com/apk/res/android"
    app:startDestination="@id/blankFragment">
    <fragment
        android:id="@+id/blankFragment"
        android:name="com.example.cashdog.cashdog.BlankFragment"
        android:label="fragment_blank"
        tools:layout="@layout/fragment_blank" >
        <action
            android:id="@+id/action_blankFragment_to_blankFragment2"
            app:destination="@id/blankFragment2" /><!-- 这里代表目的地的连接->
    </fragment>
    <fragment
        android:id="@+id/blankFragment2"
        android:name="com.example.cashdog.cashdog.BlankFragment2"
        android:label="fragment_blank_fragment2"
        tools:layout="@layout/fragment_blank_fragment2" />
</navigation>
```



### 导航到目的地

```java
NavHostFragment navHostFragment = supportFragmentManager.findFragmentById(R.id.nav_host_fragment);
NavController navController = navHostFragment.getNavController();
```





## 服务

服务（Service）是Android 中实现程序后台运行的解决方案，它非常适合用于去执行那
些不需要和用户交互而且还要求长期运行的任务。服务的运行不依赖于任何用户界面，即使
当程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。

不过需要注意的是，服务并不是运行在一个独立的进程当中的，而是依赖于创建服务
时所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的服务也会停
止运行。

服务并不会自动开启线程，所有的代码
都是默认运行在主线程当中的。也就是说，我们需要在服务的内部手动创建子线程

### 在子线程中更新UI

Android 的UI 也是线程不安全的。也就是说，如果想要更新应用程序里的UI 元素，则必须在主线程中进行，否则就会出现异常。

第一步创建Handler及相关的事件处理

```java
private Handler handler=new Handler(Looper.getMainLooper()){
        private SimpleDateFormat sdf = new SimpleDateFormat();
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch (msg.what) {
                case TimeDisplayService.DISPLAY_TIME:
                    sdf.applyPattern("HH:mm:ss");
                    Date date = new Date();// 获取当前时间
                    time.setText(sdf.format(date));
                    break;
                default:
                    break;
            }
        }
    };
```



第二步线程完成工作时调用Handler.sendMessage方法

```java
new Thread(new Runnable() {
    @Override
    public void run() {
        Message message = new Message();
        message.what = DISPLAY_TIME;
        handler.sendMessage(message);
    }
}).start();
```



### 解析异步消息处理机制

Android 中的异步消息处理主要由四个部分组成，Message、Handler、MessageQueue 和
Looper。其中Message 和Handler 在上一小节中我们已经接触过了，而MessageQueue 和Looper
对于你来说还是全新的概念，下面我就对这四个部分进行一下简要的介绍。
1. Message
Message 是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线
程之间交换数据。上一小节中我们使用到了Message 的what 字段，除此之外还可以使
用arg1 和arg2 字段来携带一些整型数据，使用obj 字段携带一个Object 对象。
2. Handler
Handler 顾名思义也就是处理者的意思，它主要是用于发送和处理消息的。发送消
息一般是使用Handler 的sendMessage()方法，而发出的消息经过一系列地辗转处理后，
最终会传递到Handler 的handleMessage()方法中。
3. MessageQueue
MessageQueue 是消息队列的意思，它主要用于存放所有通过Handler 发送的消息。
这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个MessageQueue
对象。
4. Looper
Looper 是每个线程中的MessageQueue 的管家，调用Looper 的loop()方法后，就会
进入到一个无限循环当中，然后每当发现MessageQueue 中存在一条消息，就会将它取
出，并传递到Handler 的handleMessage()方法中。每个线程中也只会有一个Looper 对象。

![image-20201113203203497](https://raw.githubusercontent.com/Explorersss/photo/master/20201113203203.png)



### 使用 AsyncTask

方便我们在子线程中对UI 进行操作

首先来看一下AsyncTask 的基本用法，由于AsyncTask 是一个抽象类，所以如果我们想
使用它，就必须要创建一个子类去继承它。在继承时我们可以为AsyncTask 类指定三个泛型
参数，这三个参数的用途如下。

1. Params
在执行AsyncTask 时需要传入的参数，可用于在后台任务中使用。
2. Progress
后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为
进度单位。

3. Result
当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值
类型。



第一步创建类

因此，一个最简单的自定义AsyncTask 就可以写成如下方式：

```java
class DownloadTask extends AsyncTask<Void, Integer, Boolean> {
……
}
```

第一个泛型参数指定为Void，表示在执行AsyncTask 的时候不
需要传入参数给后台任务。第二个泛型参数指定为Integer，表示使用整型数据来作为进度显
示单位。第三个泛型参数指定为Boolean，则表示使用布尔型数据来反馈执行结果。



第二步重写需要的方法

以下是经常重写的方法

```
1. onPreExecute()
这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比
如显示一个进度条对话框等。
2. doInBackground(Params...)
这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任
务。任务一旦完成就可以通过return 语句来将任务的执行结果返回，如果AsyncTask 的
第三个泛型参数指定的是Void，就可以不返回任务执行结果。注意，在这个方法中是不
可以进行UI 操作的，如果需要更新UI 元素，比如说反馈当前任务的执行进度，可以调
用publishProgress(Progress...)方法来完成。
3. onProgressUpdate(Progress...)
当在后台任务中调用了publishProgress(Progress...)方法后，这个方法就会很快被调
用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI 进行操
作，利用参数中的数值就可以对界面元素进行相应地更新。
4. onPostExecute(Result)
当后台任务执行完毕并通过return 语句进行返回时，这个方法就很快会被调用。返
回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI 操作，比如
说提醒任务执行的结果，以及关闭掉进度条对话框等
```



第三步启动任务

`new DownloadTask().execute();`



demo:

```java
class DownloadTask extends AsyncTask<Void, Integer, Boolean> {
    @Override
    protected void onPreExecute() {
        progressDialog.show(); // 显示进度对话框
    }
    @Override
    protected Boolean doInBackground(Void... params) {
        try {
            while (true) {
                int downloadPercent = doDownload(); // 这是一个虚构的方法
                publishProgress(downloadPercent);
                if (downloadPercent >= 100) {
                    break;
                }
            }
        } catch (Exception e) {
            return false;
        }
        return true;
    }
    @Override
    protected void onProgressUpdate(Integer... values) {
        // 在这里更新下载进度
        progressDialog.setMessage("Downloaded " + values[0] + "%");
    }
    @Override
    protected void onPostExecute(Boolean result) {
        progressDialog.dismiss(); // 关闭进度对话框
        // 在这里提示下载结果
        if (result) {
            Toast.makeText(context, "Download succeeded",
                           Toast.LENGTH_SHORT).show();
        } else {
            Toast.makeText(context, " Download failed",
                           Toast.LENGTH_SHORT).show();
        }
    }
}protected void onPreExecute() {
    progressDialog.show(); // 显示进度对话框
}
@Override
protected Boolean doInBackground(Void... params) {
    try {
        while (true) {
            int downloadPercent = doDownload(); // 这是一个虚构的方法
            publishProgress(downloadPercent);
            if (downloadPercent >= 100) {
                break;
            }
        }
    } catch (Exception e) {
        return false;
    }
    return true;
}
@Override
protected void onProgressUpdate(Integer... values) {
    // 在这里更新下载进度
    progressDialog.setMessage("Downloaded " + values[0] + "%");
}
@Override
protected void onPostExecute(Boolean result) {
    progressDialog.dismiss(); // 关闭进度对话框
    // 在这里提示下载结果
    if (result) {
        Toast.makeText(context, "Download succeeded",
                       Toast.LENGTH_SHORT).show();
    } else {
        Toast.makeText(context, " Download failed",
                       Toast.LENGTH_SHORT).show();
    }
}
}
```





### 定义一个服务

服务经常用的方法是onCreate()、onStartCommand()和onDestroy(),onBind()这四个方法

onCreate()方法会在服务创建的时候调用，onStartCommand()方法会在每次服务启动的时候调用，onDestroy()方法会在服务销毁的时候调用。

onCreate和onStartCommand的区别在于：创建和启动

```java
public class MyService extends Service {
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }
    @Override
    public void onCreate() {
        super.onCreate();
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return super.onStartCommand(intent, flags, startId);
    }
    @Override
    public void onDestroy() {
        super.onDestroy();
    }
}
```

接着需要在AndroidManifest.xml中注册

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.example.servicetest"
          android:versionCode="1"
          android:versionName="1.0" >
    ……
    <application
                 android:allowBackup="true"
                 android:icon="@drawable/ic_launcher"
                 android:label="@string/app_name"
                 android:theme="@style/AppTheme" >
        ……
        <service android:name=".MyService" >
        </service>
    </application>
</manifest>
```





### 启动/停止服务

```java
Intent startIntent = new Intent(this, MyService.class);
startService(startIntent); // 启动服务
Intent stopIntent = new Intent(this, MyService.class);
stopService(stopIntent); // 停止服务
//在Service中调用stopSelf()中即可停止服务
```



### 活动和服务进行通信



通过onBind实现活动与服务的通信



第一步创建Binder对象

```java
public class MyService extends Service {
    private DownloadBinder mBinder = new DownloadBinder();
    class DownloadBinder extends Binder {
        public void startDownload() {
            Log.d("MyService", "startDownload executed");
        }
        public int getProgress() {
            Log.d("MyService", "getProgress executed");
            return 0;
        }
    }
    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }
    ……
}
```



第二步在Activity中创建Binder和ServiceConnection

```java
private MyService.DownloadBinder downloadBinder;
private ServiceConnection connection = new ServiceConnection() {
    @Override
    public void onServiceDisconnected(ComponentName name) {
    }
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        downloadBinder = (MyService.DownloadBinder) service;
        downloadBinder.startDownload();
        downloadBinder.getProgress();
    }
};
```



重写了
onServiceConnected()方法和onServiceDisconnected()方法，这两个方法分别会在活动与服务
成功绑定以及解除绑定的时候调用。



第三步启动/销毁服务的代码：

```java
Intent bindIntent = new Intent(this, MyService.class);
bindService(bindIntent, connection, BIND_AUTO_CREATE); // 绑定服务
unbindService(connection); // 解绑服务
```

bindService()方法接收三个参数，第一个参数就
是刚刚构建出的Intent 对象，第二个参数是前面创建出的ServiceConnection 的实例，第三个
参数则是一个标志位，这里传入BIND_AUTO_CREATE 表示在活动和服务进行绑定后自动
创建服务。这会使得MyService 中的onCreate()方法得到执行，但onStartCommand()方法不
会执行。



想解除活动和服务之间的绑定该怎么办呢？调用一下unbindService()方法



### 服务的生命周期



一旦在项目的任何位置调用了Context 的startService()方法，相应的服务就会启动起来，
并回调onStartCommand()方法。**如果这个服务之前还没有创建过，onCreate()方法会先于
onStartCommand()方法执行**。服务启动了之后会一直保持运行状态，直到stopService()或
stopSelf()方法被调用。注意虽然每调用一次startService()方法，onStartCommand()就会执行
一次，但**实际上每个服务都只会存在一个实例**。所以不管你调用了多少次startService()方法，
只需调用一次stopService()或stopSelf()方法，服务就会停止下来了。
另外，还可以调用Context 的bindService()来获取一个服务的持久连接，这时就会回调
服务中的onBind()方法。类似地，如果这个服务之前还没有创建过，onCreate()方法会先于
onBind()方法执行。之后，调用方可以获取到onBind()方法里返回的IBinder 对象的实例，这
样就能自由地和服务进行通信了。只要调用方和服务之间的连接没有断开，服务就会一直保
持运行状态。
当调用了startService()方法后，又去调用stopService()方法，这时服务中的onDestroy()
方法就会执行，表示服务已经销毁了。类似地，当调用了bindService()方法后，又去调用
unbindService()方法，onDestroy()方法也会执行，这两种情况都很好理解。但是需要注意，
我们是完全有可能对一个服务既调用了startService()方法，又调用了bindService()方法的，
这种情况下该如何才能让服务销毁掉呢？根据Android 系统的机制，**一个服务只要被启动或
者被绑定了之后，就会一直处于运行状态，必须要让以上两种条件同时不满足，服务才能被
销毁。**所以，这种情况下要同时调用stopService()和unbindService()方法，onDestroy()方法才
会执行。



### 服务的更多技巧



#### 前台服务

服务的系统优先级还是比较低的，**当系统出现内存不足的情况时，就有可能会回收掉正在后台运行的服
务**。如果你希望服务可以一直保持运行状态，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台服务

前台服务和普通服务最大的区别就在于，**它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果**。



```java
public class MyService extends Service {
    @Override
    public void onCreate() {
        super.onCreate();
        Notification notification = new Notification(R.drawable.ic_launcher,
                                                     "Notification comes", System. currentTimeMillis());
        Intent notificationIntent = new Intent(this, MainActivity.class);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,
                                                                notificationIntent, 0);
        notification.setLatestEventInfo(this, "This is title", "This is
                                        content", pendingIntent);
                                        startForeground(1, notification);
                                        Log.d("MyService", "onCreate executed");
        }
                                        ……
}
```

通过创建通知的方法来变成前台进程

调用了startForeground()方法。这个方法接收两个参数，第一个参数是通知的id，类似于notify()方法的第一个参数，第二个参数则是构建出的Notification 对象。调用startForeground()方法后就会让MyService 变成一个前台服务，并在系统状态栏显示出来。





#### 使用IntentService

**服务中的代码都是默认运行在主线程当中**的，如果直接在服务里去处理一些耗时的逻辑，就很容易出现ANR（Application NotResponding）的情况。

这个时候就需要用到Android 多线程编程的技术了，我们应该在服务的每个具体的方法里开启一个子线程，然后在这里去处理那些耗时的逻辑。

但是Android 专门提供了一个IntentService 类

**这个服务在运行（onHandleIntent）结束后应该是会自动停止的**

```java
public class MyIntentService extends IntentService {
    public MyIntentService() {
        super("MyIntentService"); // 调用父类的有参构造函数
    }
    @Override
    protected void onHandleIntent(Intent intent) {
        // 打印当前线程的id
        Log.d("MyIntentService", "Thread id is " + Thread.currentThread().
              getId());
    }
    @Override
    public void onDestroy() {
        super.onDestroy();
        Log.d("MyIntentService", "onDestroy executed");
    }
}
```





### 服务的最佳实践——后台执行的定时任务

Android 中的定时任务一般有两种实现方式，一种是使用Java API 里提供的Timer 类，
一种是使用Android 的Alarm 机制。

Timer有一个明显的短板，它并不太适用于那些需要长期在后台运行的定时任务。我们都知道，为了能让电池更加耐用，每种手机都会有自己的休眠策略，**Android 手机就会在长时间不操作的情况下自动让CPU 进入到睡眠状态，这就有可能导致Timer 中的定时任务无法正常运行**。而**Alarm 机制则不存在这种情况，它具有唤醒CPU 的功能**，即可以保证每次需要执行定时任务的时候CPU 都能正常工作。需要注意，这里唤醒CPU 和唤醒屏幕完全不是同一个概念，千万不要产生混淆。

使用：

```java
AlarmManager manager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
long triggerAtTime = SystemClock.elapsedRealtime() + 10 * 1000;
manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pendingIntent);
```



set的参数解释



1. 第一个参数是一个整型参数，用于指定AlarmManager 的工作类型，有四种值可选，分别是ELAPSED_REALTIME、ELAPSED_REALTIME_WAKEUP、RTC 和RTC_WAKEUP。其中ELAPSED_REALTIME 表示让定时任务的触发时间从系统开机开始算起，但不会唤醒CPU。ELAPSED_REALTIME_WAKEUP 同样表示让定时任务的触发时间从系统开机开始算起，但会唤醒CPU。RTC 表示让定时任务的触发时间从1970 年1月1 日0 点开始算起，但不会唤醒CPU。RTC_WAKEUP 同样表示让定时任务的触发时间从1970 年1 月1 日0 点开始算起，但会唤醒CPU。使用SystemClock.elapsedRealtime()方法可以获取到系统开机至今所经历时间的毫秒数，使用System.currentTimeMillis()方法可以获取到1970 年1 月1 日0 点至今所经历时间的毫秒数。
2. 然后看一下第二个参数，这个参数就好理解多了，就是定时任务触发的时间，以毫秒为单位。如果第一个参数使用的是ELAPSED_REALTIME 或ELAPSED_REALTIME_WAKEUP，则这里传入开机至今的时间再加上延迟执行的时间。如果第一个参数使用的是RTC 或RTC_WAKEUP，则这里传入1970 年1 月1 日0 点至今的时间再加上延迟执行的时间。

3. 第三个参数是一个PendingIntent，对于它你应该已经不会陌生了吧。这里我们一般会调
   用getBroadcast()方法来获取一个能够执行广播的PendingIntent。这样当定时任务被触发的时
   候，广播接收器的onReceive()方法就可以得到执行。



demo:

```java
public class LongRunningService extends Service {
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                Log.d("LongRunningService", "executed at " + new Date().
                      toString());
            }
        }).start();
        AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE);
        int anHour = 60 * 60 * 1000; // 这是一小时的毫秒数
        long triggerAtTime = SystemClock.elapsedRealtime() + anHour;
        Intent i = new Intent(this, AlarmReceiver.class);
        PendingIntent pi = PendingIntent.getBroadcast(this, 0, i, 0);
        manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi);
        return super.onStartCommand(intent, flags, startId);
    }
}
```





AlarmReceiver:

```java
public class AlarmReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        Intent i = new Intent(context, LongRunningService.class);
        context.startService(i);
    }
}
```

保证LongRunningService 可以每隔一小时就会启动一次，一个长期在后台定时运行的
服务自然也就完成了。

**receiver记得在AndroidManifest.xml中注册**

`<receiver android:name=".AlarmReceiver" >`



另外需要注意的是，从Android 4.4 版本开始，Alarm 任务的触发时间将会变得不准确，
有可能会延迟一段时间后任务才能得到执行。这并不是个bug，而是系统在耗电性方面进行
的优化。系统会自动检测目前有多少Alarm 任务存在，然后将触发时间将近的几个任务放在
一起执行，这就可以大幅度地减少CPU 被唤醒的次数，从而有效延长电池的使用时间。
当然，如果你要求Alarm 任务的执行时间必须准备无误，Android 仍然提供了解决方案。
使用AlarmManager 的setExact()方法来替代set()方法，就可以保证任务准时执行了



### 注意事项

1. 服务默认运行在主线程中
2. 一个服务只要被启动或者被绑定了之后，就会一直处于运行状态，必须要让以上两种条件同时不满足，服务才能被销毁。
3. 每个服务都只会存在一个实例
4. Timer可能会因为电源策略而无法正常运行，而Alarm不会
5. 当系统出现内存不足的情况时，就有可能会回收掉正在后台运行的服务，此时使用前台服务解决这个问题
6. 从Android 4.4 版本开始，Alarm 任务的触发时间将会变得不准确，这是系统耗电性优化的结果，如果一定要准时执行，则使用AlarmManager 的setExact()方法来替代set()方法



## 实践

### 底部导航条

https://material.io/develop/android/components/bottom-navigation

实现：com.google.android.material.bottomnavigation.BottomNavigationView+viewpage

首先创建一个收容这两个的activity

布局文件：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        xmlns:tools="http://schemas.android.com/tools"
        android:id="@+id/container"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

    <androidx.viewpager.widget.ViewPager
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1"
            android:id="@+id/vp"
            />

    <com.google.android.material.bottomnavigation.BottomNavigationView
            android:id="@+id/bottom_navigation"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="#ECECEC"
            app:menu="@menu/bottom_navigation_menu"<!---->
            />
</LinearLayout>
```



接着为BottomNavigationView设置menu(最多设置五个，再多就会异常)

在menu下新建bottom_navigation_menu.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
      xmlns:app="http://schemas.android.com/apk/res-auto">
    <item
            android:id="@+id/course_item"
            android:enabled="true"
            android:icon="@drawable/course_icon"
            android:title="课程"
            />
    <item
            android:id="@+id/practice_item"
            android:enabled="true"
            android:icon="@drawable/practice_icon"
            android:title="习题"/>
    <item
            android:id="@+id/info_item"
            android:enabled="true"
            android:icon="@drawable/info_icon"
            android:title="我"/>
</menu>
```

接着是要添加切换fragment的逻辑

首先为viewpage设置adapter:

```java
public class BottomAdapter extends FragmentPagerAdapter {
    private List<Fragment> fragments = new ArrayList<>();

    public BottomAdapter(FragmentManager fm) {
        super(fm);
    }

    @Override
    public Fragment getItem(int position) {
        return fragments.get(position);
    }

    @Override
    public int getCount() {
        return fragments.size();
    }

    public void addFragment(Fragment fragment) {
        fragments.add(fragment);
    }
}
```

在activity类中添加切换代码

```java

public class MainActivity extends AppCompatActivity {

    private BottomNavigationView mBv;
    private ViewPager mVp;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initView();
    }
    private void initView() {
        mBv = (BottomNavigationView) findViewById(R.id.bottom_navigation);
        mVp = (ViewPager) findViewById(R.id.vp);
        mBv.setOnNavigationItemSelectedListener(new BottomNavigationView.OnNavigationItemSelectedListener() {
            @Override
            public boolean onNavigationItemSelected(MenuItem menuItem) {
                switch (menuItem.getItemId()){
                    case R.id.course_item:
                        mVp.setCurrentItem(0);
                        break;
                    case R.id.practice_item:
                        mVp.setCurrentItem(1);
                        break;
                    case R.id.info_item:
                        mVp.setCurrentItem(2);
                        break;
                    default:
                        return false;
                }
                return true;
            }
        });



        setupViewPager(mVp);
        mVp.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
            @Override
            public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {

            }

            @Override
            public void onPageSelected(int position) {
                mBv.getMenu().getItem(position).setChecked(true);
            }

            @Override
            public void onPageScrollStateChanged(int state) {

            }
        });

    }

    private void setupViewPager(ViewPager viewPager) {
        BottomAdapter adapter = new BottomAdapter(getSupportFragmentManager());
        adapter.addFragment(new CourseFragment());
        adapter.addFragment(new PracticeFragment());
        adapter.addFragment(new InfoFragment());
        viewPager.setAdapter(adapter);
    }

}
```



#### 去除tint

删除AppTheme中的颜色定义

#### 为icon设置选中和没选中的不同样式

drawable下新建

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_checked="true" android:drawable="@drawable/main_course_icon_selected"/>
    <item android:state_checked="false" android:drawable="@drawable/main_course_icon"/>
</selector>

```

将icon设置为这个即可





## 使用网络技术



### WebView

使用WebView来代替通过浏览器来访问网页

第一步添加权限，在AndroidManifest.xml的manifest下添加

```xml
<uses-permission android:name="android.permission.INTERNET" />
```

第二步设置布局



第三步

```java
public class MainActivity extends Activity {
    private WebView webView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        webView = (WebView) findViewById(R.id.web_view);
        webView.getSettings().setJavaScriptEnabled(true);
        webView.setWebViewClient(new WebViewClient() {
            @Override
            public boolean shouldOverrideUrlLoading(WebView view, String
                                                    url) {
                view.loadUrl(url); // 根据传入的参数再去加载新的网页
                return true; // 表示当前WebView可以处理打开新网页的请求，不用借助
                系统浏览器
            }
        });
        webView.loadUrl("http://www.baidu.com");
    }
}
```



### 发送HTTP请求

#### HttpURLConnection



```java
URL url = new URL("http://www.baidu.com");
HttpURLConnection connection = (HttpURLConnection) url.openConnection();
connection.setRequestMethod("GET");
connection.setConnectTimeout(8000);
connection.setReadTimeout(8000);
InputStream in = connection.getInputStream();
connection.disconnect();
//post请求
connection.setRequestMethod("POST");
DataOutputStream out = new DataOutputStream(connection.getOutputStream());
out.writeBytes("username=admin&password=123456");
```



#### HttpClient

HttpClient 是Apache 提供的HTTP 网络访问接口



```java
//发送请求
////get
HttpClient httpClient = new DefaultHttpClient();
HttpGet httpGet = new HttpGet("http://www.baidu.com");
HttpResponse httpResponse = httpClient.execute(httpGet);
////post
HttpPost httpPost = new HttpPost("http://www.baidu.com");
List<NameValuePair> params = new ArrayList<NameValuePair>();
params.add(new BasicNameValuePair("username", "admin"));
params.add(new BasicNameValuePair("password", "123456"));
UrlEncodedFormEntity entity = new UrlEncodedFormEntity(params, "utf-8");
httpPost.setEntity(entity);
HttpResponse httpResponse = httpClient.execute(httpGet);
//判断响应代码
if (httpResponse.getStatusLine().getStatusCode() == 200) {
// 请求和响应都成功了
}
// 获取返回内容
HttpEntity entity = httpResponse.getEntity();
String response = EntityUtils.toString(entity);
String response = EntityUtils.toString(entity, "utf-8");
```



执行execute()方法之后会返回一个HttpResponse 对象，服务器所返回的所有信息就会包
含在这里面





### 解析xml数据



#### Pull解析



```java
private void parseXMLWithPull(String xmlData) {
    try {
        XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
        XmlPullParser xmlPullParser = factory.newPullParser();
        xmlPullParser.setInput(new StringReader(xmlData));
        int eventType = xmlPullParser.getEventType();
        String id = "";
        String name = "";
        String version = "";
        while (eventType != XmlPullParser.END_DOCUMENT) {
            String nodeName = xmlPullParser.getName();
            switch (eventType) {
                    // 开始解析某个结点
                case XmlPullParser.START_TAG: {
                    if ("id".equals(nodeName)) {
                        id = xmlPullParser.nextText();
                    } else if ("name".equals(nodeName)) {
                        name = xmlPullParser.nextText();
                    } else if ("version".equals(nodeName)) {
                        version = xmlPullParser.nextText();
                    }
                    break;
                }
                case XmlPullParser.END_TAG: {
                    if ("app".equals(nodeName)) {
                        Log.d("MainActivity", "id is " + id);
                        Log.d("MainActivity", "name is " + name);
                        Log.d("MainActivity", "version is " + version);
                    }
                    break;
                }
                default:
                    break;
            }
            eventType = xmlPullParser.next();
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```





#### SAX解析方式

通常情况下我们都会新建一个类继承自DefaultHandler，并重写父类的五个方法，如下
所示：



```java
public class ContentHandler extends DefaultHandler {
    private String nodeName;
    private StringBuilder id;
    private StringBuilder name;
    private StringBuilder version;
    @Override
    public void startDocument() throws SAXException {
        id = new StringBuilder();
        name = new StringBuilder();
        version = new StringBuilder();
    }
    @Override
    public void startElement(String uri, String localName, String qName,
                             Attributes attributes) throws SAXException {
        // 记录当前结点名
        nodeName = localName;
    }
    @Override
    public void characters(char[] ch, int start, int length) throws
        SAXException {
        // 根据当前的结点名判断将内容添加到哪一个StringBuilder对象中
        if ("id".equals(nodeName)) {
            id.append(ch, start, length);
        } else if ("name".equals(nodeName)) {
            name.append(ch, start, length);
        } else if ("version".equals(nodeName)) {
            version.append(ch, start, length);
        }
    }
    @Override
    public void endElement(String uri, String localName, String qName) throws
        SAXException {
        if ("app".equals(localName)) {
            Log.d("ContentHandler", "id is " + id.toString().trim());
            Log.d("ContentHandler", "name is " + name.toString().trim());
            Log.d("ContentHandler", "version is " + version.toString().trim());
            // 最后要将StringBuilder清空掉
            id.setLength(0);
            name.setLength(0);
            version.setLength(0);
        }
    }
    @Override
    public void endDocument() throws SAXException {
    }
}
```

startDocument()方法会在开始XML 解析的时候调用，
startElement()方法会在开始解析某个结点的时候调用，characters()方法会在获取结点中内容
的时候调用，endElement()方法会在完成解析某个结点的时候调用，endDocument()方法会在
完成整个XML 解析的时候调用。其中，startElement()、characters()和endElement()这三个方
法是有参数的，从XML 中解析出的数据就会以参数的形式传入到这些方法中。需要注意的
是，在获取结点中的内容时，characters()方法可能会被调用多次，一些换行符也被当作内容
解析出来，我们需要针对这种情况在代码中做好控制。



接着就是传入xml数据

```java
private void parseXMLWithSAX(String xmlData) {
    try {
        SAXParserFactory factory = SAXParserFactory.newInstance();
        XMLReader xmlReader = factory.newSAXParser().getXMLReader();
        ContentHandler handler = new ContentHandler();
        // 将ContentHandler的实例设置到XMLReader中
        xmlReader.setContentHandler(handler);
        // 开始执行解析
        xmlReader.parse(new InputSource(new StringReader(xmlData)));
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```





### 解析JSON数据



#### JSONObject



```java
private void parseJSONWithJSONObject(String jsonData) {
    try {
        JSONArray jsonArray = new JSONArray(jsonData);
        for (int i = 0; i < jsonArray.length(); i++) {
            JSONObject jsonObject = jsonArray.getJSONObject(i);
            String id = jsonObject.getString("id");
            String name = jsonObject.getString("name");
            String version = jsonObject.getString("version");
            Log.d("MainActivity", "id is " + id);
            Log.d("MainActivity", "name is " + name);
            Log.d("MainActivity", "version is " + version);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

#### GSON

设置好Persion属性的get方法和set方法



```java
Gson gson = new Gson();
Person person = gson.fromJson(jsonData, Person.class);
List<Person> people = gson.fromJson(jsonData, new TypeToken<List<Person>>()
{}.getType());
```



### 网络编程的最佳实践

封装请求代码，利用回调来处理得到的响应（新建子线程来完成这个耗时操作）



```java
public interface HttpCallbackListener {
    void onFinish(String response);
    void onError(Exception e);
}
public class HttpUtil {
    public static void sendHttpRequest(final String address, final
                                       HttpCallbackListener listener) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                HttpURLConnection connection = null;
                try {
                    URL url = new URL(address);
                    connection = (HttpURLConnection) url.openConnection();
                    connection.setRequestMethod("GET");
                    connection.setConnectTimeout(8000);
                    connection.setReadTimeout(8000);
                    connection.setDoInput(true);
                    connection.setDoOutput(true);
                    InputStream in = connection.getInputStream();
                    BufferedReader reader = new BufferedReader(new
                                                               InputStreamReader(in));
                    StringBuilder response = new StringBuilder();
                    
                    String line;
                    while ((line = reader.readLine()) != null) {
                        response.append(line);
                    }
                    if (listener != null) {
                        // 回调onFinish()方法
                        listener.onFinish(response.toString());
                    }
                } catch (Exception e) {
                    if (listener != null) {
                        // 回调onError()方法
                        listener.onError(e);
                    }
                } finally {
                    if (connection != null) {
                        connection.disconnect();
                    }
                }
            }
        }).start();
    }
}
```





## 文档

### android官方文档



### material文档

https://material.io/develop/android





## 遇到的问题

### NoClassDefFoundError: Failed resolution of: Landroid/view/View$OnUnhandledKeyEventListener

https://stackoverflow.com/questions/51782548/androidxappcompat-iart-error-android-view-viewonunhandledkeyeventlistener/52954286#52954286

解决方案：implementation 'androidx.appcompat:appcompat:1.3.0-alpha02'

