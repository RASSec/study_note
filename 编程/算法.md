# 算法考试



## 图论



### BFS(广度优先)

 所谓宽度优先。就是每次都尝试访问同一层的节点。 如果同一层都访问完了，再访问下一层。 



### DFS(深度优先)

 所谓深度优先，就是说每次都尝试向更深的节点走 

 DFS 最显著的特征在于其 **递归调用自身** 。同时与 BFS 类似，DFS 会对其访问过的点打上访问标记，在遍历图时跳过已打过标记的点，以确保 **每个点仅访问一次** 。符合以上两条规则的函数，便是广义上的 DFS 



## 栈



### 求所有出栈的可能性个数

 https://blog.csdn.net/sinat_29912455/article/details/51946401 

![](https://img-blog.csdn.net/20170325201912485?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1eWFxaTE5OTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)





## 堆

堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于/小于等于其父亲的键值。

 每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆 

习惯上，不加限定提到“堆”时往往都指二叉堆。

### 二叉堆

从二叉堆的结构说起，它是一棵二叉树，并且是完全二叉树，每个结点中存有一个元素（或者说，有个权值）。

堆性质：父亲的权值不小于儿子的权值（大根堆）



## 哈希表



### 哈希函数



#### 直接定址法

f(key)=key

#### 平方取中法



key^2^取中间几位



#### 数字分析法



找到冲突较小的位数



#### 折叠法

1. 移位叠加(01-1234-5678   =>  p=5678+1234+0001)
2. 间界叠加(01-1234-5678 => p=5678+4321+0001)



#### 除留余数法



h(key)=key%p

p为质数

### 解决冲突的方法

#### 拉链法

 拉链法是在每个存放数据的地方开一个链表，如果有多个 key 索引到同一个地方，只用把他们都放到那个位置的链表里就行了。查询的时候需要把对应位置的链表整个扫一遍，对其中的每个数据比较其 key 与查询的 key 是否一致。如果索引的范围是 1~M，哈希表的大小为 N，那么一次插入/查询需要进行期望O(N/M)次比较。 

#### 闭散列法(开放定址法)

 闭散列方法把所有记录直接存储在散列表中，如果发生冲突则根据某种方式继续进行探查。 

其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：

Hi=（H（key）+di）% m; i=1，2，…，n

其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：

##### 线性探查法

di=1，2，3，…，m-1

这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。

##### 平方探查法

平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²...直到找到空闲单元。
 在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。

##### 双重散列法

 它不是检查冲突位置后的每一个位置，而是采用另一个散列函数产生一个固定的增量。（跳跃式检查和插入，减小聚焦大小） 



##### 二次探测

di=1^2^，-(1^2^)，2^2^，-(2^2^)，…，k^2^，-(k^2^) ( k<=m/2 )



#### 公共溢出区法

这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。



## 树

### 树的表示方式

- 广义表
- 嵌套集合
- 凹入表示

### 树的基本术语

- 结点的度:结点拥有的子树数
- 分支结点:非叶子结点称为分支结点
- 内部结点:除根结点以外的分支结点
- 树的度:最大的结点的度
- 有序树,无序树,森林



### 树的存储结构



#### 父亲表示法

特点找父亲容易找孩子难

#### 孩子表示法

找孩子容易,找双亲难



#### 左孩子右兄弟表示法



### 树和二叉树的转化

- 将树转为二叉树
  兄弟相连留长子
- 将二叉树转为树
  左孩右右连父亲,去掉原来右孩线



### 森林和二叉树的转化

- 森林转二叉树
  树变二叉根相连
- 二叉树转森林
  去掉全部右孩线,孤立二叉再还原



### 森林的遍历



将其转为二叉树

再进行前序,后序,中序遍历



### 树的遍历

前序遍历,后序遍历,层次遍历.



### 哈夫曼树(最优二叉树)

#### 概念

结点的路径长度:两结点间路径上的分支数

树的路径长度:从树根到每一个结点的路径长度之和

结点的带权路径长度:从根结点到该结点之间的路径长度与该结点的权的乘积

 树的带权路径长度: 树中所有叶子结点的带权路径长度之和

#### 哈曼夫树的基本概念及性质

在某一度下,带权路径长度(wpl)最短的树

性质:

- 权越大离根节点越近
- 相同的带权结点有不同的哈曼夫树
- 在哈夫曼算法中,初始时有N个二叉树,要经过n-1次合并最终形成哈夫曼树
- 在哈夫曼树中不存在度为1的结点





#### 如何构造哈夫曼树

1. 构造森林全是根
2. 选用两小造新树
3. 删除两小添新人
4. 重复2,3剩单根

#### 哈曼夫树的应用

##### 哈夫曼编码

统计字符集中每一个字符在电文中出现的平均概率,利用平均概率构建哈夫曼树,左分支标0,右分支标1



哈夫曼编码是最优前缀码





### 二叉树

#### 二叉树的定义

严格来说二叉树并不是树,二叉树是一个有序树,严格区分左右子树

#### 二叉树的性质

1. 在二叉树的第i层至多有2^(i-1)^个结点(i>=1)
2. 深度为k的二叉树最多有2^k^-1个结点
3. 对任何二叉树,如果其中的叶子数为n0,度为2的结点数位n2,则n0=n2+1



#### 满二叉树和完全二叉树

##### 满二叉树的定义及性质

定义:深度为k且有2^k^-1个结点的二叉树称为满二叉树
性质:每层都满,叶子结点全在最底层

编号规则:

- 从根节点开始,自上而下,自左而右
- 每一个结点都有元素



##### 完全二叉树的定义及性质

定义: 深度为k的具有n个结点的二叉树,当且仅当其每一个结点都与深度为k的满二叉树中编号为1-n的结点一一对应时,称之为完全二叉树

性质:

1. 具有n个结点的完全二叉树的深度为[(log2n)的底+1]
2. (从1开始编号)如果i>1,它的父亲结点是i/2的底
3. 编号为i的结点,其左儿子和右儿子的结点分别为:2i+1,2i+2



#### 二叉树的存储结构

- 顺序存储
- 链式存储
  二叉链表,三叉链表



#### 遍历二叉树

均采用递归方法实现

##### 前序遍历



##### 后序遍历



##### 中序遍历



##### 层次遍历

采用队列来实现,先入队根结点.

出队的同时入队其左右子节点

#### 线索二叉树

利用空指针域,左空指向前驱结点(相对遍历结果),右空指向后继(相对遍历结果)





## 图

### 图的定义和术语

```
图:G=(V,E) Graph=(Vertex,Edge)
V:顶点(数据元素)的有穷非空集合
E:边的有穷集合
```



完全图:任意两个点都有一条边相连

无向完全图边的个数(n个顶点):n(n-1)/2

有向完全图边的个数:n*(n-1)



弧:有向图的边

稀疏图:有很少边或弧的图(e(边)<nlogn)

网:边/弧带权的图

邻接: 有边/弧相连的两个顶点之间的关系

存在(vi,vj)则称vi和vj互为邻接点

存在`<vi,vj>`则称vi邻接到vj,vj邻接于vi

关联(依附):边/弧与顶点之间的关系

路径:连续的边构成的顶点序列

路径长度:路径上边或弧的数目/权值之和

简单路径:除路径起点和终点可以相同外,其余顶点均不相同的路径

连通图(强连通图):在无(有)向图G=(V,{E})中,若对任何两个顶点v,u都存在从v到u的路径,则称G是连通图(强连通图).

连通分量:无向图G的极大连通子图称为G的连通分量

强连通分量:有向图的极大强连通子图称为G的强连通分量

极小连通子图:该子图G的连通子图.在该子图中删除任何一条边,该子图不再连通

生成树:包含无向图G的所有顶点的极小连通子图

生成森林:对非连通图,由各个连通分量的生成树的集合

### 图的存储结构

#### 邻接矩阵表示法



一个顶点表

一个邻接矩阵`arr[i][j]`,从i到j有边,则`arr[i][j]`置一,否则为0

- 无向图邻接矩阵性质
  某个点的度=第i行(列)中1的个数

- 有向图邻接矩阵性质
  某个顶点的出度:第i行中1的个数
  某个顶点的入度:第i列中1的个数
- 网的邻接矩阵:将1换位权值

#### 邻接表表示法

- 无向图

![image.png](https://ws1.sinaimg.cn/large/006pWR9agy1ga9a30ig2zj30v60e1anb.jpg)



- 有向图

邻接表:邻接表保存当前顶点指向的边

逆邻接表:与邻接表相反



#### 十字链表

![image.png](https://ws1.sinaimg.cn/large/006pWR9aly1ga9bd686btj30lf0bhgrm.jpg)





#### 邻接多重表

![image.png](https://ws1.sinaimg.cn/large/006pWR9aly1ga9bll7g8dj30xy0iwtvj.jpg)



### 图的遍历



#### DFS

递归实现

![image.png](https://ws1.sinaimg.cn/large/006pWR9agy1ga9byaqdvxj30iy08xn36.jpg)



#### BFS



![image.png](https://ws1.sinaimg.cn/large/006pWR9aly1ga9bzlneioj30rw05qq7i.jpg)



利用队列实现

### 生成树

![image.png](https://ws1.sinaimg.cn/large/006pWR9agy1ga9ccihhasj30nj0bak28.jpg)

#### 如何生成

遍历一遍,把遍历过的路径记录下来就形成了生成树


#### 最小生成树

![image.png](https://ws1.sinaimg.cn/large/006pWR9aly1ga9chp5jodj30uk0c97ep.jpg)



##### mst性质



![image.png](https://ws1.sinaimg.cn/large/006pWR9agy1ga9covn2t7j30wv0ha4i2.jpg)





![image.png](https://ws1.sinaimg.cn/large/006pWR9agy1ga9cocqqopj30vf0fs16k.jpg)





##### Prim算法

![image.png](https://ws1.sinaimg.cn/large/006pWR9agy1ga9cxc2cn3j30uo0g4dtm.jpg)





##### Kruskal 算法

![image.png](https://ws1.sinaimg.cn/large/006pWR9agy1ga9d102kqlj30w70gyqno.jpg)



##### 两种算法的比较

![image.png](https://ws1.sinaimg.cn/large/006pWR9aly1ga9d3fzghdj30qc0f4dn8.jpg)







### 最短路径

- 两点间最短路径

- 某源点出发到其他各点最短路径



#### Dijkstra算法

 算法思想：设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。 



总结:和V0直连边中最短的边,一定是最短距离,因为从V0不可能从其他更长的路径来到达该结点.

新加入一个已经求得最短路径的点后,会产生新的最短路径,重复上述步骤,检测该点的出度

#### Floyd 算法

 [https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/Floyd-Warshall算法) 



```c++
for (k = 1; k <= n; k++) {
  for (i = 1; i <= n; i++) {
    for (j = 1; j <= n; j++) {
      f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
    }
  }
}
```





